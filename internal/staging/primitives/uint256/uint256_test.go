// Copyright (c) 2021 The Decred developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package uint256

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"math/big"
	"math/rand"
	"reflect"
	"testing"
	"time"
)

// hexToBytes converts the passed hex string into bytes and will panic if there
// is an error.  This is only provided for the hard-coded constants so errors in
// the source code can be detected. It will only (and must only) be called with
// hard-coded values.
func hexToBytes(s string) []byte {
	b, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid hex in source file: " + s)
	}
	return b
}

// hexToUint256 converts the passed hex string into a Uint256 and will panic if
// there is an error.  This is only provided for the hard-coded constants so
// errors in the source code can be detected. It will only (and must only) be
// called with hard-coded values.
func hexToUint256(s string) *Uint256 {
	if len(s)%2 != 0 {
		s = "0" + s
	}
	b := hexToBytes(s)
	if len(b) > 32 {
		panic("hex in source file overflows mod 2^256: " + s)
	}
	return new(Uint256).SetByteSlice(b)
}

// randBigIntAndUint256 returns a big integer and a uint256 both created from
// the same random value generated by the passed rng.
func randBigIntAndUint256(t *testing.T, rng *rand.Rand) (*big.Int, *Uint256) {
	t.Helper()

	var buf [32]byte
	if _, err := rng.Read(buf[:]); err != nil {
		t.Fatalf("failed to read random: %v", err)
	}

	// Create and return both a big integer and a uint256.
	bigIntVal := new(big.Int).SetBytes(buf[:])
	ui256Val := new(Uint256).SetBytes(&buf)
	return bigIntVal, ui256Val
}

// TestUint256SetUint64 ensures that setting a scalar to various native integers
// works as expected.
func TestUint256SetUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		n    uint64    // test value
		want [4]uint64 // expected words
	}{{
		name: "five",
		n:    0x5,
		want: [4]uint64{0x5, 0, 0, 0},
	}, {
		name: "2^32 - 1",
		n:    0xffffffff,
		want: [4]uint64{0xffffffff, 0, 0, 0},
	}, {
		name: "2^32",
		n:    0x100000000,
		want: [4]uint64{0x100000000, 0, 0, 0},
	}, {
		name: "2^64 - 1",
		n:    0xffffffffffffffff,
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}}

	for _, test := range tests {
		n := new(Uint256).SetUint64(test.n)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%s: wrong result -- got: %x want: %x", test.name, n.n,
				test.want)
			continue
		}
	}
}

// TestUint256SetBytes ensures that setting a uint256 to a 256-bit big-endian
// unsigned integer via both the slice and array methods works as expected for
// edge cases.  Random cases are tested via the various other tests.
func TestUint256SetBytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		in   string    // hex encoded test value
		want [4]uint64 // expected words
	}{{
		name: "empty",
		in:   "",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "zero",
		in:   "00",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "one",
		in:   "0000000000000000000000000000000000000000000000000000000000000001",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "2^64-1 (no leading zeros)",
		in:   "ffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}, {
		name: "2^128-1 (with leading zeros)",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0xffffffffffffffff, 0, 0},
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: [4]uint64{
			0xffffffffffffffff, 0xffffffffffffffff,
			0xffffffffffffffff, 0xffffffffffffffff,
		},
	}, {
		name: "2^8 - 1 (truncated >32 bytes)",
		in:   "0100000000000000000000000000000000000000000000000000000000000000ff",
		want: [4]uint64{0xff, 0, 0, 0},
	}, {
		name: "progression",
		in:   "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
		want: [4]uint64{
			0x191a1b1c1d1e1f20, 0x1112131415161718,
			0x090a0b0c0d0e0f10, 0x0102030405060708,
		},
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: [4]uint64{
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
		},
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: [4]uint64{
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
		},
	}}

	for _, test := range tests {
		inBytes := hexToBytes(test.in)

		// Ensure setting the bytes via the slice method works as expected.
		var n Uint256
		n.SetByteSlice(inBytes)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%s: unexpected result -- got: %x, want: %x", test.name,
				n.n, test.want)
			continue
		}

		// Ensure setting the bytes via the array method works as expected.
		var n2 Uint256
		var b32 [32]byte
		truncatedInBytes := inBytes
		if len(truncatedInBytes) > 32 {
			truncatedInBytes = truncatedInBytes[len(truncatedInBytes)-32:]
		}
		copy(b32[32-len(truncatedInBytes):], truncatedInBytes)
		n2.SetBytes(&b32)
		if !reflect.DeepEqual(n2.n, test.want) {
			t.Errorf("%s: unexpected result -- got: %x, want: %x", test.name,
				n2.n, test.want)
			continue
		}
	}
}

// TestUint256SetBytesLE ensures that setting a uint256 to a 256-bit
// little-endian unsigned integer via both the slice and array methods works as
// expected for edge cases.
func TestUint256SetBytesLE(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		in   string    // hex encoded test value
		want [4]uint64 // expected words
	}{{
		name: "empty",
		in:   "",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "zero",
		in:   "00",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "one",
		in:   "01",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "2^64-1 (no trailing zeros)",
		in:   "ffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}, {
		name: "2^128-1 (with trailing zeros)",
		in:   "ffffffffffffffffffffffffffffffff00000000000000000000000000000000",
		want: [4]uint64{0xffffffffffffffff, 0xffffffffffffffff, 0, 0},
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: [4]uint64{
			0xffffffffffffffff, 0xffffffffffffffff,
			0xffffffffffffffff, 0xffffffffffffffff,
		},
	}, {
		name: "one (truncated >32 bytes)",
		in:   "0100000000000000000000000000000000000000000000000000000000000000ff",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "progression",
		in:   "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
		want: [4]uint64{
			0x0807060504030201, 0x100f0e0d0c0b0a09,
			0x1817161514131211, 0x201f1e1d1c1b1a19,
		},
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: [4]uint64{
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
		},
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: [4]uint64{
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
		},
	}}

	for _, test := range tests {
		inBytes := hexToBytes(test.in)

		// Ensure setting the bytes via the slice method works as expected.
		var n Uint256
		n.SetByteSliceLE(inBytes)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n.n, test.want)
			continue
		}

		// Ensure setting the bytes via the array method works as expected.
		var n2 Uint256
		var b32 [32]byte
		truncatedInBytes := inBytes
		if len(truncatedInBytes) > 32 {
			truncatedInBytes = truncatedInBytes[:32]
		}
		copy(b32[:], truncatedInBytes)
		n2.SetBytesLE(&b32)
		if !reflect.DeepEqual(n2.n, test.want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n2.n, test.want)
			continue
		}
	}
}

// TestUint256Bytes ensures that retrieving the bytes for a uint256 encoded as a
// 256-bit big-endian unsigned integer via the various methods works as expected
// for edge cases.  Random cases are tested via the various other tests.
func TestUint256Bytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		in   string // hex encoded test value
		want string // expected hex encoded bytes
	}{{
		name: "zero",
		in:   "0",
		want: "0000000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "one",
		in:   "1",
		want: "0000000000000000000000000000000000000000000000000000000000000001",
	}, {
		name: "2^64 - 1",
		in:   "000000000000000000000000000000000000000000000000ffffffffffffffff",
		want: "000000000000000000000000000000000000000000000000ffffffffffffffff",
	}, {
		name: "2^128 - 1",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
	}, {
		name: "2^192 - 1",
		in:   "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
	}}

	for _, test := range tests {
		n := hexToUint256(test.in)
		want := hexToBytes(test.want)

		// Ensure getting the bytes works as expected.
		gotBytes := n.Bytes()
		if !bytes.Equal(gotBytes[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				gotBytes, want)
			continue
		}

		// Ensure getting the bytes directly into an array works as expected.
		var b32 [32]byte
		n.PutBytes(&b32)
		if !bytes.Equal(b32[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				b32, want)
			continue
		}

		// Ensure getting the bytes directly into a slice works as expected.
		var buffer [64]byte
		n.PutBytesUnchecked(buffer[:])
		if !bytes.Equal(buffer[:32], want) {
			t.Errorf("%q: unexpected result, got: %x, want: %x", test.name,
				buffer[:32], want)
			continue
		}
	}
}

// TestUint256BytesLE ensures that retrieving the bytes for a uint256 encoded as
// a 256-bit little-endian unsigned integer via the various methods works as
// expected for edge cases.
func TestUint256BytesLE(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		in   string // hex encoded test value
		want string // expected hex encoded bytes
	}{{
		name: "zero",
		in:   "0",
		want: "0000000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "one",
		in:   "1",
		want: "0100000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "2^64 - 1",
		in:   "000000000000000000000000000000000000000000000000ffffffffffffffff",
		want: "ffffffffffffffff000000000000000000000000000000000000000000000000",
	}, {
		name: "2^128 - 1",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffff00000000000000000000000000000000",
	}, {
		name: "2^192 - 1",
		in:   "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000",
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
	}}

	for _, test := range tests {
		n := hexToUint256(test.in)
		want := hexToBytes(test.want)

		// Ensure getting the bytes works as expected.
		gotBytes := n.BytesLE()
		if !bytes.Equal(gotBytes[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				gotBytes, want)
			continue
		}

		// Ensure getting the bytes directly into an array works as expected.
		var b32 [32]byte
		n.PutBytesLE(&b32)
		if !bytes.Equal(b32[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				b32, want)
			continue
		}

		// Ensure getting the bytes directly into a slice works as expected.
		var buffer [64]byte
		n.PutBytesUncheckedLE(buffer[:])
		if !bytes.Equal(buffer[:32], want) {
			t.Errorf("%q: unexpected result, got: %x, want: %x", test.name,
				buffer[:32], want)
			continue
		}
	}
}

// TestUint256Zero ensures that zeroing a uint256 works as expected.
func TestUint256Zero(t *testing.T) {
	t.Parallel()

	n := hexToUint256("a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5")
	n.Zero()
	for idx, word := range n.n {
		if word != 0 {
			t.Errorf("internal word at index #%d is not zero - got %d", idx,
				word)
		}
	}
}

// TestUint256IsZero ensures that checking if a uint256 is zero works as
// expected.
func TestUint256IsZero(t *testing.T) {
	t.Parallel()

	var n Uint256
	if !n.IsZero() {
		t.Fatalf("new uint256 is not zero - got %v (words %x)", n, n.n)
	}

	n.SetUint64(1)
	if n.IsZero() {
		t.Fatalf("claims zero for nonzero uint256 - got %v (words %x)", n, n.n)
	}

	n.SetUint64(0)
	if !n.IsZero() {
		t.Fatalf("claims nonzero for zero uint256 - got %v (words %x)", n, n.n)
	}

	n.SetUint64(1)
	n.Zero()
	if !n.IsZero() {
		t.Fatalf("claims zero for nonzero uint256 - got %v (words %x)", n, n.n)
	}
}

// TestUint256IsUint32 ensures that checking if a uint256 can be represented as
// a uint32 without loss of precision works as expected.
func TestUint256IsUint32(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want bool   // expected result
	}{{
		name: "zero",
		n:    "0",
		want: true,
	}, {
		name: "one",
		n:    "1",
		want: true,
	}, {
		name: "two",
		n:    "2",
		want: true,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: true,
	}, {
		name: "2^32",
		n:    "100000000",
		want: false,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: false,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: false,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: false,
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: false,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).IsUint32()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %v, want: %v", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Uint32 ensures that treating a uint256 as a uint32 produces the
// expected result.
func TestUint256Uint32(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want uint32 // expected uint32
	}{{
		name: "zero",
		n:    "0",
		want: 0,
	}, {
		name: "one",
		n:    "1",
		want: 1,
	}, {
		name: "two",
		n:    "2",
		want: 2,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: 0xffffffff,
	}, {
		name: "2^32",
		n:    "100000000",
		want: 0,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: 0xfffffffe,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: 0xffffffff,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: 0,
	}, {
		name: "2^192 - 2^16 + 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffff0000",
		want: 0xffff0000,
	}, {
		name: "2^256 - 2^31",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffff",
		want: 0x7fffffff,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).Uint32()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256IsUint64 ensures that checking if a uint256 can be represented as
// a uint64 without loss of precision works as expected.
func TestUint256IsUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want bool   // expected result
	}{{
		name: "zero",
		n:    "0",
		want: true,
	}, {
		name: "one",
		n:    "1",
		want: true,
	}, {
		name: "two",
		n:    "2",
		want: true,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: true,
	}, {
		name: "2^32",
		n:    "100000000",
		want: true,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: true,
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: true,
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: false,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: false,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: false,
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: false,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).IsUint64()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %v, want: %v", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Uint64 ensures that treating a uint256 as a uint64 produces the
// expected result.
func TestUint256Uint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want uint64 // expected uint64
	}{{
		name: "zero",
		n:    "0",
		want: 0,
	}, {
		name: "one",
		n:    "1",
		want: 1,
	}, {
		name: "two",
		n:    "2",
		want: 2,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: 0xffffffff,
	}, {
		name: "2^32",
		n:    "100000000",
		want: 0x100000000,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: 0xfffffffffffffffe,
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: 0xffffffffffffffff,
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: 0,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: 0xffffffffffffffff,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: 0,
	}, {
		name: "2^192 - 2^16 + 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffff0000",
		want: 0xffffffffffff0000,
	}, {
		name: "2^256 - 2^63",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffff",
		want: 0x7fffffffffffffff,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).Uint64()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Comparison ensures that comparing two uint256s via the various
// comparison operators works as expected for edge cases.
func TestUint256Comparison(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string // test description
		n1      string // hex encoded value
		n2      string // hex encoded value
		wantCmp int    // expected comparison result
	}{{
		name:    "0 vs 0",
		n1:      "0",
		n2:      "0",
		wantCmp: 0,
	}, {
		name:    "0 vs 1",
		n1:      "0",
		n2:      "1",
		wantCmp: -1,
	}, {
		name:    "1 vs 0",
		n1:      "1",
		n2:      "0",
		wantCmp: 1,
	}, {
		name:    "2^32 - 1 vs 2^32 - 1",
		n1:      "ffffffff",
		n2:      "ffffffff",
		wantCmp: 0,
	}, {
		name:    "2^32 - 1 vs 2^32",
		n1:      "ffffffff",
		n2:      "100000000",
		wantCmp: -1,
	}, {
		name:    "2^32 vs 2^32 - 1",
		n1:      "100000000",
		n2:      "ffffffff",
		wantCmp: 1,
	}, {
		name:    "2^32 vs 2^32",
		n1:      "100000000",
		n2:      "100000000",
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64 - 2",
		n1:      "ffffffffffffffff",
		n2:      "fffffffffffffffe",
		wantCmp: 1,
	}, {
		name:    "2^64 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffff",
		n2:      "ffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64",
		n1:      "ffffffffffffffff",
		n2:      "10000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^64 vs 2^64 - 1",
		n1:      "10000000000000000",
		n2:      "ffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^64 vs 2^64",
		n1:      "10000000000000000",
		n2:      "10000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^128 - 1 vs 2^128 - 1",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^128 - 1 vs 2^128",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      "100000000000000000000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^128 vs 2^128 - 1",
		n1:      "100000000000000000000000000000000",
		n2:      "ffffffffffffffffffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^128 vs 2^128",
		n1:      "100000000000000000000000000000000",
		n2:      "100000000000000000000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^192 - 1 vs 2^192 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^192 - 1 vs 2^192",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "1000000000000000000000000000000000000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^192 vs 2^192 - 1",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^192 vs 2^192",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      "1000000000000000000000000000000000000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^256 - 1 vs 2^256 - 2",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
		wantCmp: 1,
	}, {
		name:    "2^256 - 1 vs 2^256 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}}

	for _, test := range tests {
		// Ensure comparing the numbers produces the expected cmp result.
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		gotCmp := n1.Cmp(n2)
		if gotCmp != test.wantCmp {
			t.Errorf("%q: incorrect cmp result -- got: %v, want: %v", test.name,
				gotCmp, test.wantCmp)
			continue
		}

		// Ensure comparing the numbers produces the expected == result.
		isEq := n1.Eq(n2)
		wantEq := test.wantCmp == 0
		if isEq != wantEq {
			t.Errorf("%q: incorrect == result -- got: %v, want: %v", test.name,
				isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.Lt(n2)
		wantLt := test.wantCmp < 0
		if isLt != wantLt {
			t.Errorf("%q: incorrect < result -- got: %v, want: %v", test.name,
				isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEq(n2)
		wantLtEq := test.wantCmp <= 0
		if isLtEq != wantLtEq {
			t.Errorf("%q: incorrect <= result -- got: %v, want: %v", test.name,
				isLtEq, wantLtEq)
			continue
		}

		// Ensure comparing the numbers produces the expected > result.
		isGt := n1.Gt(n2)
		wantGt := test.wantCmp > 0
		if isGt != wantGt {
			t.Errorf("%q: incorrect > result -- got: %v, want: %v", test.name,
				isGt, wantGt)
			continue
		}

		// Ensure comparing the numbers produces the expected >= result.
		isGtEq := n1.GtEq(n2)
		wantGtEq := test.wantCmp >= 0
		if isGtEq != wantGtEq {
			t.Errorf("%q: incorrect >= result -- got: %v, want: %v", test.name,
				isGtEq, wantGtEq)
			continue
		}
	}
}

// TestUint256ComparisonRandom ensures that comparing two uint256s created from
// random values via the various comparison operators works as expected.
func TestUint256ComparisonRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Ensure the uint256s are equal to themselves.
		if !n1.Eq(n1) {
			t.Fatalf("failed equality check -- n1: %x", n1)
		}
		if !n2.Eq(n2) {
			t.Fatalf("failed equality check -- n2: %x", n2)
		}

		// Ensure the uint256 comparison result matches the one using big ints.
		bigCmpResult := bigN1.Cmp(bigN2)
		cmpResult := n1.Cmp(n2)
		if cmpResult != bigCmpResult {
			t.Errorf("incorrect cmp result n1: %x, n2: %x -- got %v, want %v",
				n1, n2, cmpResult, bigCmpResult)
		}

		// Ensure comparing the numbers produces the expected == result.
		isEq := n1.Eq(n2)
		wantEq := bigCmpResult == 0
		if isEq != wantEq {
			t.Errorf("incorrect == result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.Lt(n2)
		wantLt := bigCmpResult < 0
		if isLt != wantLt {
			t.Errorf("incorrect < result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEq(n2)
		wantLtEq := bigCmpResult <= 0
		if isLtEq != wantLtEq {
			t.Errorf("incorrect <= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLtEq, wantLtEq)
			continue
		}

		// Ensure comparing the numbers produces the expected > result.
		isGt := n1.Gt(n2)
		wantGt := bigCmpResult > 0
		if isGt != wantGt {
			t.Errorf("incorrect > result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isGt, wantGt)
			continue
		}

		// Ensure comparing the numbers produces the expected >= result.
		isGtEq := n1.GtEq(n2)
		wantGtEq := bigCmpResult >= 0
		if isGtEq != wantGtEq {
			t.Errorf("incorrect >= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isGtEq, wantGtEq)
			continue
		}
	}
}

// TestUint256ComparisonUint64 ensures that comparing a uint256 and a uint64 via
// the various comparison operators works as expected for edge cases.
func TestUint256ComparisonUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string // test description
		n1      string // hex encoded value
		n2      uint64 // uint64 to compare with
		wantCmp int    // expected comparison result
	}{{
		name:    "0 vs 0",
		n1:      "0",
		n2:      0,
		wantCmp: 0,
	}, {
		name:    "0 vs 1",
		n1:      "0",
		n2:      1,
		wantCmp: -1,
	}, {
		name:    "1 vs 0",
		n1:      "1",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^32 - 1 vs 2^32 - 1",
		n1:      "ffffffff",
		n2:      0xffffffff,
		wantCmp: 0,
	}, {
		name:    "2^32 - 1 vs 2^32",
		n1:      "ffffffff",
		n2:      0x100000000,
		wantCmp: -1,
	}, {
		name:    "2^32 vs 2^32 - 1",
		n1:      "100000000",
		n2:      0xffffffff,
		wantCmp: 1,
	}, {
		name:    "2^32 vs 2^32",
		n1:      "100000000",
		n2:      0x100000000,
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64 - 2",
		n1:      "ffffffffffffffff",
		n2:      0xfffffffffffffffe,
		wantCmp: 1,
	}, {
		name:    "2^64 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 0,
	}, {
		name:    "2^64 vs 2^64 - 1",
		n1:      "10000000000000000",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^128 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^128 vs 0",
		n1:      "100000000000000000000000000000000",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^192 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^192 vs 0",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^256 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}}

	for _, test := range tests {
		// Ensure comparing the numbers produces the expected cmp result.
		n1 := hexToUint256(test.n1)
		gotCmp := n1.CmpUint64(test.n2)
		if gotCmp != test.wantCmp {
			t.Errorf("%q: incorrect cmp result -- got: %v, want: %v", test.name,
				gotCmp, test.wantCmp)
			continue
		}

		// Ensure comparing the numbers produces the expected == result.
		isEq := n1.EqUint64(test.n2)
		wantEq := test.wantCmp == 0
		if isEq != wantEq {
			t.Errorf("%q: incorrect == result -- got: %v, want: %v", test.name,
				isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.LtUint64(test.n2)
		wantLt := test.wantCmp < 0
		if isLt != wantLt {
			t.Errorf("%q: incorrect < result -- got: %v, want: %v", test.name,
				isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEqUint64(test.n2)
		wantLtEq := test.wantCmp <= 0
		if isLtEq != wantLtEq {
			t.Errorf("%q: incorrect <= result -- got: %v, want: %v", test.name,
				isLt, wantLtEq)
			continue
		}

		// Ensure comparing the numbers produces the expected > result.
		isGt := n1.GtUint64(test.n2)
		wantGt := test.wantCmp > 0
		if isGt != wantGt {
			t.Errorf("%q: incorrect > result -- got: %v, want: %v", test.name,
				isGt, wantGt)
			continue
		}

		// Ensure comparing the numbers produces the expected >= result.
		isGtEq := n1.GtEqUint64(test.n2)
		wantGtEq := test.wantCmp >= 0
		if isGtEq != wantGtEq {
			t.Errorf("%q: incorrect >= result -- got: %v, want: %v", test.name,
				isGtEq, wantGtEq)
			continue
		}
	}
}

// TestUint256ComparisonUint64Random ensures that comparing a uint256 vs uint64
// created from random values via the various comparison operators works as
// expected.
func TestUint256ComparisonUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256/uint64 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Ensure a the uint256 truncated to 64 bits equals that truncated
		// 64-bit result.
		truncatedN1Uint64 := n1.Uint64()
		truncatedN1 := new(Uint256).SetUint64(truncatedN1Uint64)
		if !truncatedN1.EqUint64(truncatedN1Uint64) {
			t.Fatalf("failed equality check -- n: %x", truncatedN1)
		}

		// Ensure the uint256 comparison result matches the one using big ints.
		bigCmpResult := bigN1.Cmp(bigN2)
		cmpResult := n1.CmpUint64(n2)
		if cmpResult != bigCmpResult {
			t.Errorf("incorrect cmp result n1: %x, n2: %x -- got %v, want %v",
				n1, n2, cmpResult, bigCmpResult)
		}

		// Ensure comparing the numbers produces the expected == result.
		isEq := n1.EqUint64(n2)
		wantEq := bigCmpResult == 0
		if isEq != wantEq {
			t.Errorf("incorrect == result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.LtUint64(n2)
		wantLt := bigCmpResult < 0
		if isLt != wantLt {
			t.Errorf("incorrect < result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEqUint64(n2)
		wantLtEq := bigCmpResult <= 0
		if isLtEq != wantLtEq {
			t.Errorf("incorrect <= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLtEq, wantLtEq)
			continue
		}

		// Ensure comparing the numbers produces the expected > result.
		isGt := n1.GtUint64(n2)
		wantGt := bigCmpResult > 0
		if isGt != wantGt {
			t.Errorf("incorrect > result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isGt, wantGt)
			continue
		}

		// Ensure comparing the numbers produces the expected >= result.
		isGtEq := n1.GtEqUint64(n2)
		wantGtEq := bigCmpResult >= 0
		if isGtEq != wantGtEq {
			t.Errorf("incorrect >= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isGtEq, wantGtEq)
			continue
		}
	}
}

// TestUint256Add ensures that adding two uint256s works as expected for edge
// cases.
func TestUint256Add(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded test value
		n2   string // second hex encoded test value
		want string // expected hex encoded result
	}{{
		name: "zero + one",
		n1:   "0",
		n2:   "1",
		want: "1",
	}, {
		name: "one + zero",
		n1:   "1",
		n2:   "0",
		want: "1",
	}, {
		name: "max uint256 + 1 (carry in all words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "1",
		want: "0",
	}, {
		name: "max uint256 + 2 (carry in all words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "2",
		want: "1",
	}, {
		name: "(2^64 - 15) + 16 (carry in word zero)",
		n1:   "fffffffffffffff0",
		n2:   "10",
		want: "10000000000000000",
	}, {
		name: "carry in word one",
		n1:   "0000ffff000000000000000000000000",
		n2:   "ffff0001000000000000000000000000",
		want: "100000000000000000000000000000000",
	}, {
		name: "carry in word two",
		n1:   "0000ffff0000000000000000000000000000000000000000",
		n2:   "ffff00010000000000000000000000000000000000000000",
		want: "1000000000000000000000000000000000000000000000000",
	}, {
		name: "carry in word three",
		n1:   "0000ffff00000000000000000000000000000000000000000000000000000000",
		n2:   "ffff000100000000000000000000000000000000000000000000000000000000",
		want: "0",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}}

	for _, test := range tests {
		// Parse test hex.
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		want := hexToUint256(test.want)

		// Ensure adding the two values produces the expected result.
		got := new(Uint256).Add2(n1, n2)
		if !got.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				got, want)
			continue
		}

		// Ensure single argument adding also produces the expected result.
		n1.Add(n2)
		if !n1.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n1, want)
			continue
		}
	}
}

// TestUint256AddRandom ensures that adding two uint256s created from random
// values together works as expected by also performing the same operation with
// big ints and comparing the results.
func TestUint256AddRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Calculate the sum of the values using big ints.
		bigIntResult := new(big.Int).Add(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the sum of the values using uint256s.
		uint256Result := new(Uint256).Add2(n1, n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched add n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256AddUint64 ensures that adding a uint64 to a uint256 works as
// expected for edge cases.
func TestUint256AddUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded test value
		n2   uint64 // uint64 test value
		want string // expected hex encoded result
	}{{
		name: "zero + one",
		n1:   "0",
		n2:   1,
		want: "1",
	}, {
		name: "one + zero",
		n1:   "1",
		n2:   0,
		want: "1",
	}, {
		name: "max uint256 + 1 (carry in all words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   1,
		want: "0",
	}, {
		name: "max uint256 + 2 (carry in all words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   2,
		want: "1",
	}, {
		name: "(2^64 - 15) + 16 (carry in word zero)",
		n1:   "fffffffffffffff0",
		n2:   0x10,
		want: "10000000000000000",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   0x5a5a5a5a5a5a5a5a,
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5ffffffffffffffff",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   0xa5a5a5a5a5a5a5a5,
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5affffffffffffffff",
	}}

	for _, test := range tests {
		// Parse test hex.
		n1 := hexToUint256(test.n1)
		want := hexToUint256(test.want)

		// Ensure the result is the expected value.
		n1.AddUint64(test.n2)
		if !n1.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n1, want)
			continue
		}
	}
}

// TestUint256AddUint64Random ensures that adding a uint64 to a uint256
// together, both created from random values, works as expected by also
// performing the same operation with big ints and comparing the results.
func TestUint256AddUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Calculate the sum of the values using big ints.
		bigIntResult := new(big.Int).Add(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the sum of the values using uint256s.
		uint256Result := new(Uint256).Set(n1).AddUint64(n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched add n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256Sub ensures that subtracting two uint256s works as expected for
// edge cases.
func TestUint256Sub(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded test value
		n2   string // second hex encoded test value
		want string // expected hex encoded result
	}{{
		name: "zero - one (borrow in all words)",
		n1:   "0",
		n2:   "1",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "one - zero",
		n1:   "1",
		n2:   "0",
		want: "1",
	}, {
		name: "max uint256 - 1",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "1",
		want: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^64 + 15) - 16 (borrow in word zero)",
		n1:   "1000000000000000f",
		n2:   "10",
		want: "ffffffffffffffff",
	}, {
		name: "borrow in word one",
		n1:   "100000000000000000000000000000000",
		n2:   "080000000000000000000000000000000",
		want: "80000000000000000000000000000000",
	}, {
		name: "borrow in word two",
		n1:   "1000000000000000000000000000000000000000000000000",
		n2:   "0800000000000000000000000000000000000000000000000",
		want: "800000000000000000000000000000000000000000000000",
	}, {
		name: "borrow in word three",
		n1:   "6000000000000000000000000000000000000000000000000000000000000000",
		n2:   "8000000000000000000000000000000000000000000000000000000000000000",
		want: "e000000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b5",
	}}

	for _, test := range tests {
		// Parse test hex.
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		want := hexToUint256(test.want)

		// Ensure subtracting the two values produces the expected result.
		got := new(Uint256).Sub2(n1, n2)
		if !got.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				got, want)
			continue
		}

		// Ensure single argument subtracting also produces the expected result.
		n1.Sub(n2)
		if !n1.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n1, want)
			continue
		}
	}
}

// TestUint256SubRandom ensures that subtracting two uint256s created from
// random values works as expected by also performing the same operation with
// big ints and comparing the results.
func TestUint256SubRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Calculate the difference of the values using big ints.
		bigIntResult := new(big.Int).Sub(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the difference of the values using uint256s.
		uint256Result := new(Uint256).Sub2(n1, n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched sub n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256SubUint64 ensures that adding a uint64 to a uint256 works as
// expected for edge cases.
func TestUint256SubUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded test value
		n2   uint64 // uint64 test value
		want string // expected hex encoded result
	}{{
		name: "zero - one (borrow in all words)",
		n1:   "0",
		n2:   1,
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "one - zero",
		n1:   "1",
		n2:   0,
		want: "1",
	}, {
		name: "max uint256 - 1",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   1,
		want: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^64 + 15) - 16 (borrow in word zero)",
		n1:   "1000000000000000f",
		n2:   0x10,
		want: "ffffffffffffffff",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   0x5a5a5a5a5a5a5a5a,
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a54b4b4b4b4b4b4b4b",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   0xa5a5a5a5a5a5a5a5,
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a59b4b4b4b4b4b4b4b5",
	}}

	for _, test := range tests {
		// Parse test hex.
		n1 := hexToUint256(test.n1)
		want := hexToUint256(test.want)

		// Ensure the result is the expected value.
		n1.SubUint64(test.n2)
		if !n1.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n1, want)
			continue
		}
	}
}

// TestUint256SubUint64Random ensures that subtracting a uint64 from a uint256
// together, both created from random values, works as expected by also
// performing the same operation with big ints and comparing the results.
func TestUint256SubUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Calculate the difference of the values using big ints.
		bigIntResult := new(big.Int).Sub(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the difference of the values using uint256s.
		uint256Result := new(Uint256).Set(n1).SubUint64(n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched sub n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256Mul ensures that multiplying two uint256s together works as
// expected for edge cases.
func TestUint256Mul(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded value
		n2   string // second hex encoded value to multiply with
		want string // expected hex encoded value
	}{{
		name: "zero * zero",
		n1:   "0",
		n2:   "0",
		want: "0",
	}, {
		name: "zero * one",
		n1:   "0",
		n2:   "1",
		want: "0",
	}, {
		name: "one * zero",
		n1:   "1",
		n2:   "0",
		want: "0",
	}, {
		name: "one * one",
		n1:   "1",
		n2:   "1",
		want: "1",
	}, {
		name: "(2^64 - 1) * 2 (carry to word 1)",
		n1:   "ffffffffffffffff",
		n2:   "2",
		want: "1fffffffffffffffe",
	}, {
		name: "(2^128 - 1) * 2  (carry to word 2)",
		n1:   "ffffffffffffffffffffffffffffffff",
		n2:   "2",
		want: "1fffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^192 - 1) * 2  (carry to word 3)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "2",
		want: "1fffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^256 - 1) * 2  (carry to word 4)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "2",
		want: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^256 - 1) * (2^256 - 1) (carry through all 8 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "1",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "4d10d4985c1fe3a76b2ef2b67a3e01c5894d10d4985c1fe3a76b2ef2b67a3e02",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "4d10d4985c1fe3a76b2ef2b67a3e01c5894d10d4985c1fe3a76b2ef2b67a3e02",
	}}

	for _, test := range tests {
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		want := hexToUint256(test.want)

		// Ensure multiplying two other values produces the expected result.
		got := new(Uint256).Mul2(n1, n2)
		if !got.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				want)
			continue
		}

		// Ensure single argument multiplying also produces the expected result.
		n1.Mul(n2)
		if !n1.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n1,
				want)
			continue
		}
	}
}

// TestUint256MulRandom ensures that multiplying two uint256s created from
// random values together works as expected by also performing the same
// operation with big ints and comparing the results.
func TestUint256MulRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Calculate the product of the values using big ints.
		bigIntResult := new(big.Int).Mul(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the product of the values using uint256s.
		uint256Result := new(Uint256).Mul2(n1, n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched mul n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256MulUint64 ensures that multiplying a uint256 by a uint64 works as
// expected for edge cases.
func TestUint256MulUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded value
		n2   uint64 // uint64 to multiply with
		want string // expected hex encoded value
	}{{
		name: "zero * zero",
		n1:   "0",
		n2:   0,
		want: "0",
	}, {
		name: "zero * one",
		n1:   "0",
		n2:   1,
		want: "0",
	}, {
		name: "one * zero",
		n1:   "1",
		n2:   0,
		want: "0",
	}, {
		name: "one * one",
		n1:   "1",
		n2:   1,
		want: "1",
	}, {
		name: "(2^64 - 1) * 2 (carry to word 1)",
		n1:   "ffffffffffffffff",
		n2:   2,
		want: "1fffffffffffffffe",
	}, {
		name: "(2^128 - 1) * 2  (carry to word 2)",
		n1:   "ffffffffffffffffffffffffffffffff",
		n2:   2,
		want: "1fffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^192 - 1) * 2  (carry to word 3)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   2,
		want: "1fffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^256 - 1) * 2  (carry to word 4)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   2,
		want: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^256 - 1) * (2^64 - 1) (max uint64)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   0xffffffffffffffff,
		want: "ffffffffffffffffffffffffffffffffffffffffffffffff0000000000000001",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   0x5a5a5a5a5a5a5a5a,
		want: "e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1a76b2ef2b67a3e02",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   0xa5a5a5a5a5a5a5a5,
		want: "e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1a76b2ef2b67a3e02",
	}}

	for _, test := range tests {
		n1 := hexToUint256(test.n1)
		want := hexToUint256(test.want)

		// Ensure single multiplying produces the expected result.
		n1.MulUint64(test.n2)
		if !n1.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n1,
				want)
			continue
		}
	}
}

// TestUint256MulUint64Random ensures that multiplying a uint256 by a uint64,
// both created from random values, works as expected by also performing the
// same operation with big ints and comparing the results.
func TestUint256MulUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Calculate the product of the values using big ints.
		bigIntResult := new(big.Int).Mul(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the product of the values using uint256s.
		uint256Result := new(Uint256).Set(n1).MulUint64(n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched mul n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256Square ensures that squaring uint256s works as expected for edge
// cases.
func TestUint256Square(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded test value
		want string // expected hex encoded value
	}{{
		name: "zero",
		n:    "0",
		want: "0",
	}, {
		name: "one",
		n:    "1",
		want: "1",
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: "fffffffffffffffe0000000000000001",
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: "100000000000000000000000000000000",
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: "fffffffffffffffffffffffffffffffe00000000000000000000000000000001",
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: "0",
	}, {
		name: "2^192 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "fffffffffffffffe000000000000000000000000000000000000000000000001",
	}, {
		name: "2^192",
		n:    "1000000000000000000000000000000000000000000000000",
		want: "0",
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "1",
	}, {
		name: "alternating bits",
		n:    "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "0d4985c1fe3a76b2ef2b67a3e01c5894d10d4985c1fe3a76b2ef2b67a3e01c59",
	}, {
		name: "alternating bits 2",
		n:    "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "5894d10d4985c1fe3a76b2ef2b67a3e01c5894d10d4985c1fe3a76b2ef2b67a4",
	}}

	for _, test := range tests {
		n := hexToUint256(test.n)
		want := hexToUint256(test.want)

		// Ensure squaring a value produces the expected result.
		got := new(Uint256).SquareVal(n)
		if !got.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				want)
			continue
		}

		// Ensure self squaring also produces the expected result.
		n.Square()
		if !n.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n,
				want)
			continue
		}
	}
}

// TestUint256SquareRandom ensures that squaring uint256s created from random
// values works as expected by also performing the same operation with big ints
// and comparing the results.
func TestUint256SquareRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate big integer and uint256 pair.
		bigN, n := randBigIntAndUint256(t, rng)

		// Calculate the square of the value using big ints.
		bigIntResult := new(big.Int).Mul(bigN, bigN)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the square of the value using uint256s.
		uint256Result := new(Uint256).SquareVal(n)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched square n: %x -- got %x, want %x", n,
				bigIntResult, uint256Result)
		}
	}
}
