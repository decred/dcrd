// Copyright (c) 2021 The Decred developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package uint256

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"math/big"
	"math/rand"
	"reflect"
	"testing"
	"time"
)

// hexToBytes converts the passed hex string into bytes and will panic if there
// is an error.  This is only provided for the hard-coded constants so errors in
// the source code can be detected. It will only (and must only) be called with
// hard-coded values.
func hexToBytes(s string) []byte {
	b, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid hex in source file: " + s)
	}
	return b
}

// hexToUint256 converts the passed hex string into a Uint256 and will panic if
// there is an error.  This is only provided for the hard-coded constants so
// errors in the source code can be detected. It will only (and must only) be
// called with hard-coded values.
func hexToUint256(s string) *Uint256 {
	if len(s)%2 != 0 {
		s = "0" + s
	}
	b := hexToBytes(s)
	if len(b) > 32 {
		panic("hex in source file overflows mod 2^256: " + s)
	}
	return new(Uint256).SetByteSlice(b)
}

// randBigIntAndUint256 returns a big integer and a uint256 both created from
// the same random value generated by the passed rng.
func randBigIntAndUint256(t *testing.T, rng *rand.Rand) (*big.Int, *Uint256) {
	t.Helper()

	var buf [32]byte
	if _, err := rng.Read(buf[:]); err != nil {
		t.Fatalf("failed to read random: %v", err)
	}

	// Create and return both a big integer and a uint256.
	bigIntVal := new(big.Int).SetBytes(buf[:])
	ui256Val := new(Uint256).SetBytes(&buf)
	return bigIntVal, ui256Val
}

// TestUint256SetUint64 ensures that setting a scalar to various native integers
// works as expected.
func TestUint256SetUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		n    uint64    // test value
		want [4]uint64 // expected words
	}{{
		name: "five",
		n:    0x5,
		want: [4]uint64{0x5, 0, 0, 0},
	}, {
		name: "2^32 - 1",
		n:    0xffffffff,
		want: [4]uint64{0xffffffff, 0, 0, 0},
	}, {
		name: "2^32",
		n:    0x100000000,
		want: [4]uint64{0x100000000, 0, 0, 0},
	}, {
		name: "2^64 - 1",
		n:    0xffffffffffffffff,
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}}

	for _, test := range tests {
		n := new(Uint256).SetUint64(test.n)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%s: wrong result -- got: %x want: %x", test.name, n.n,
				test.want)
			continue
		}
	}
}

// TestUint256SetBytes ensures that setting a uint256 to a 256-bit big-endian
// unsigned integer via both the slice and array methods works as expected for
// edge cases.  Random cases are tested via the various other tests.
func TestUint256SetBytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		in   string    // hex encoded test value
		want [4]uint64 // expected words
	}{{
		name: "empty",
		in:   "",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "zero",
		in:   "00",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "one",
		in:   "0000000000000000000000000000000000000000000000000000000000000001",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "2^64-1 (no leading zeros)",
		in:   "ffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}, {
		name: "2^128-1 (with leading zeros)",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0xffffffffffffffff, 0, 0},
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: [4]uint64{
			0xffffffffffffffff, 0xffffffffffffffff,
			0xffffffffffffffff, 0xffffffffffffffff,
		},
	}, {
		name: "2^8 - 1 (truncated >32 bytes)",
		in:   "0100000000000000000000000000000000000000000000000000000000000000ff",
		want: [4]uint64{0xff, 0, 0, 0},
	}, {
		name: "progression",
		in:   "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
		want: [4]uint64{
			0x191a1b1c1d1e1f20, 0x1112131415161718,
			0x090a0b0c0d0e0f10, 0x0102030405060708,
		},
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: [4]uint64{
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
		},
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: [4]uint64{
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
		},
	}}

	for _, test := range tests {
		inBytes := hexToBytes(test.in)

		// Ensure setting the bytes via the slice method works as expected.
		var n Uint256
		n.SetByteSlice(inBytes)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%s: unexpected result -- got: %x, want: %x", test.name,
				n.n, test.want)
			continue
		}

		// Ensure setting the bytes via the array method works as expected.
		var n2 Uint256
		var b32 [32]byte
		truncatedInBytes := inBytes
		if len(truncatedInBytes) > 32 {
			truncatedInBytes = truncatedInBytes[len(truncatedInBytes)-32:]
		}
		copy(b32[32-len(truncatedInBytes):], truncatedInBytes)
		n2.SetBytes(&b32)
		if !reflect.DeepEqual(n2.n, test.want) {
			t.Errorf("%s: unexpected result -- got: %x, want: %x", test.name,
				n2.n, test.want)
			continue
		}
	}
}

// TestUint256SetBytesLE ensures that setting a uint256 to a 256-bit
// little-endian unsigned integer via both the slice and array methods works as
// expected for edge cases.
func TestUint256SetBytesLE(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		in   string    // hex encoded test value
		want [4]uint64 // expected words
	}{{
		name: "empty",
		in:   "",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "zero",
		in:   "00",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "one",
		in:   "01",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "2^64-1 (no trailing zeros)",
		in:   "ffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}, {
		name: "2^128-1 (with trailing zeros)",
		in:   "ffffffffffffffffffffffffffffffff00000000000000000000000000000000",
		want: [4]uint64{0xffffffffffffffff, 0xffffffffffffffff, 0, 0},
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: [4]uint64{
			0xffffffffffffffff, 0xffffffffffffffff,
			0xffffffffffffffff, 0xffffffffffffffff,
		},
	}, {
		name: "one (truncated >32 bytes)",
		in:   "0100000000000000000000000000000000000000000000000000000000000000ff",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "progression",
		in:   "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
		want: [4]uint64{
			0x0807060504030201, 0x100f0e0d0c0b0a09,
			0x1817161514131211, 0x201f1e1d1c1b1a19,
		},
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: [4]uint64{
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
		},
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: [4]uint64{
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
		},
	}}

	for _, test := range tests {
		inBytes := hexToBytes(test.in)

		// Ensure setting the bytes via the slice method works as expected.
		var n Uint256
		n.SetByteSliceLE(inBytes)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n.n, test.want)
			continue
		}

		// Ensure setting the bytes via the array method works as expected.
		var n2 Uint256
		var b32 [32]byte
		truncatedInBytes := inBytes
		if len(truncatedInBytes) > 32 {
			truncatedInBytes = truncatedInBytes[:32]
		}
		copy(b32[:], truncatedInBytes)
		n2.SetBytesLE(&b32)
		if !reflect.DeepEqual(n2.n, test.want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n2.n, test.want)
			continue
		}
	}
}

// TestUint256Bytes ensures that retrieving the bytes for a uint256 encoded as a
// 256-bit big-endian unsigned integer via the various methods works as expected
// for edge cases.  Random cases are tested via the various other tests.
func TestUint256Bytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		in   string // hex encoded test value
		want string // expected hex encoded bytes
	}{{
		name: "zero",
		in:   "0",
		want: "0000000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "one",
		in:   "1",
		want: "0000000000000000000000000000000000000000000000000000000000000001",
	}, {
		name: "2^64 - 1",
		in:   "000000000000000000000000000000000000000000000000ffffffffffffffff",
		want: "000000000000000000000000000000000000000000000000ffffffffffffffff",
	}, {
		name: "2^128 - 1",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
	}, {
		name: "2^192 - 1",
		in:   "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
	}}

	for _, test := range tests {
		n := hexToUint256(test.in)
		want := hexToBytes(test.want)

		// Ensure getting the bytes works as expected.
		gotBytes := n.Bytes()
		if !bytes.Equal(gotBytes[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				gotBytes, want)
			continue
		}

		// Ensure getting the bytes directly into an array works as expected.
		var b32 [32]byte
		n.PutBytes(&b32)
		if !bytes.Equal(b32[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				b32, want)
			continue
		}

		// Ensure getting the bytes directly into a slice works as expected.
		var buffer [64]byte
		n.PutBytesUnchecked(buffer[:])
		if !bytes.Equal(buffer[:32], want) {
			t.Errorf("%q: unexpected result, got: %x, want: %x", test.name,
				buffer[:32], want)
			continue
		}
	}
}

// TestUint256BytesLE ensures that retrieving the bytes for a uint256 encoded as
// a 256-bit little-endian unsigned integer via the various methods works as
// expected for edge cases.
func TestUint256BytesLE(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		in   string // hex encoded test value
		want string // expected hex encoded bytes
	}{{
		name: "zero",
		in:   "0",
		want: "0000000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "one",
		in:   "1",
		want: "0100000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "2^64 - 1",
		in:   "000000000000000000000000000000000000000000000000ffffffffffffffff",
		want: "ffffffffffffffff000000000000000000000000000000000000000000000000",
	}, {
		name: "2^128 - 1",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffff00000000000000000000000000000000",
	}, {
		name: "2^192 - 1",
		in:   "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000",
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
	}}

	for _, test := range tests {
		n := hexToUint256(test.in)
		want := hexToBytes(test.want)

		// Ensure getting the bytes works as expected.
		gotBytes := n.BytesLE()
		if !bytes.Equal(gotBytes[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				gotBytes, want)
			continue
		}

		// Ensure getting the bytes directly into an array works as expected.
		var b32 [32]byte
		n.PutBytesLE(&b32)
		if !bytes.Equal(b32[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				b32, want)
			continue
		}

		// Ensure getting the bytes directly into a slice works as expected.
		var buffer [64]byte
		n.PutBytesUncheckedLE(buffer[:])
		if !bytes.Equal(buffer[:32], want) {
			t.Errorf("%q: unexpected result, got: %x, want: %x", test.name,
				buffer[:32], want)
			continue
		}
	}
}

// TestUint256Zero ensures that zeroing a uint256 works as expected.
func TestUint256Zero(t *testing.T) {
	t.Parallel()

	n := hexToUint256("a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5")
	n.Zero()
	for idx, word := range n.n {
		if word != 0 {
			t.Errorf("internal word at index #%d is not zero - got %d", idx,
				word)
		}
	}
}

// TestUint256IsZero ensures that checking if a uint256 is zero works as
// expected.
func TestUint256IsZero(t *testing.T) {
	t.Parallel()

	var n Uint256
	if !n.IsZero() {
		t.Fatalf("new uint256 is not zero - got %v (words %x)", n, n.n)
	}

	n.SetUint64(1)
	if n.IsZero() {
		t.Fatalf("claims zero for nonzero uint256 - got %v (words %x)", n, n.n)
	}

	n.SetUint64(0)
	if !n.IsZero() {
		t.Fatalf("claims nonzero for zero uint256 - got %v (words %x)", n, n.n)
	}

	n.SetUint64(1)
	n.Zero()
	if !n.IsZero() {
		t.Fatalf("claims zero for nonzero uint256 - got %v (words %x)", n, n.n)
	}
}

// TestUint256IsOdd ensures that checking if a uint256 is odd works as expected.
func TestUint256IsOdd(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want bool   // expected oddness
	}{{
		name: "zero",
		n:    "0",
		want: false,
	}, {
		name: "one",
		n:    "1",
		want: true,
	}, {
		name: "two",
		n:    "2",
		want: false,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: true,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: false,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: true,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: false,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).IsOdd()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %v, want: %v", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256IsUint32 ensures that checking if a uint256 can be represented as
// a uint32 without loss of precision works as expected.
func TestUint256IsUint32(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want bool   // expected result
	}{{
		name: "zero",
		n:    "0",
		want: true,
	}, {
		name: "one",
		n:    "1",
		want: true,
	}, {
		name: "two",
		n:    "2",
		want: true,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: true,
	}, {
		name: "2^32",
		n:    "100000000",
		want: false,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: false,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: false,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: false,
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: false,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).IsUint32()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %v, want: %v", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Uint32 ensures that treating a uint256 as a uint32 produces the
// expected result.
func TestUint256Uint32(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want uint32 // expected uint32
	}{{
		name: "zero",
		n:    "0",
		want: 0,
	}, {
		name: "one",
		n:    "1",
		want: 1,
	}, {
		name: "two",
		n:    "2",
		want: 2,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: 0xffffffff,
	}, {
		name: "2^32",
		n:    "100000000",
		want: 0,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: 0xfffffffe,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: 0xffffffff,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: 0,
	}, {
		name: "2^192 - 2^16 + 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffff0000",
		want: 0xffff0000,
	}, {
		name: "2^256 - 2^31",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffff",
		want: 0x7fffffff,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).Uint32()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256IsUint64 ensures that checking if a uint256 can be represented as
// a uint64 without loss of precision works as expected.
func TestUint256IsUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want bool   // expected result
	}{{
		name: "zero",
		n:    "0",
		want: true,
	}, {
		name: "one",
		n:    "1",
		want: true,
	}, {
		name: "two",
		n:    "2",
		want: true,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: true,
	}, {
		name: "2^32",
		n:    "100000000",
		want: true,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: true,
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: true,
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: false,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: false,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: false,
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: false,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).IsUint64()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %v, want: %v", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Uint64 ensures that treating a uint256 as a uint64 produces the
// expected result.
func TestUint256Uint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want uint64 // expected uint64
	}{{
		name: "zero",
		n:    "0",
		want: 0,
	}, {
		name: "one",
		n:    "1",
		want: 1,
	}, {
		name: "two",
		n:    "2",
		want: 2,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: 0xffffffff,
	}, {
		name: "2^32",
		n:    "100000000",
		want: 0x100000000,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: 0xfffffffffffffffe,
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: 0xffffffffffffffff,
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: 0,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: 0xffffffffffffffff,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: 0,
	}, {
		name: "2^192 - 2^16 + 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffff0000",
		want: 0xffffffffffff0000,
	}, {
		name: "2^256 - 2^63",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffff",
		want: 0x7fffffffffffffff,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).Uint64()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Comparison ensures that comparing two uint256s via the various
// comparison operators works as expected for edge cases.
func TestUint256Comparison(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string // test description
		n1      string // hex encoded value
		n2      string // hex encoded value
		wantCmp int    // expected comparison result
	}{{
		name:    "0 vs 0",
		n1:      "0",
		n2:      "0",
		wantCmp: 0,
	}, {
		name:    "0 vs 1",
		n1:      "0",
		n2:      "1",
		wantCmp: -1,
	}, {
		name:    "1 vs 0",
		n1:      "1",
		n2:      "0",
		wantCmp: 1,
	}, {
		name:    "2^32 - 1 vs 2^32 - 1",
		n1:      "ffffffff",
		n2:      "ffffffff",
		wantCmp: 0,
	}, {
		name:    "2^32 - 1 vs 2^32",
		n1:      "ffffffff",
		n2:      "100000000",
		wantCmp: -1,
	}, {
		name:    "2^32 vs 2^32 - 1",
		n1:      "100000000",
		n2:      "ffffffff",
		wantCmp: 1,
	}, {
		name:    "2^32 vs 2^32",
		n1:      "100000000",
		n2:      "100000000",
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64 - 2",
		n1:      "ffffffffffffffff",
		n2:      "fffffffffffffffe",
		wantCmp: 1,
	}, {
		name:    "2^64 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffff",
		n2:      "ffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64",
		n1:      "ffffffffffffffff",
		n2:      "10000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^64 vs 2^64 - 1",
		n1:      "10000000000000000",
		n2:      "ffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^64 vs 2^64",
		n1:      "10000000000000000",
		n2:      "10000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^128 - 1 vs 2^128 - 1",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^128 - 1 vs 2^128",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      "100000000000000000000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^128 vs 2^128 - 1",
		n1:      "100000000000000000000000000000000",
		n2:      "ffffffffffffffffffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^128 vs 2^128",
		n1:      "100000000000000000000000000000000",
		n2:      "100000000000000000000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^192 - 1 vs 2^192 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^192 - 1 vs 2^192",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "1000000000000000000000000000000000000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^192 vs 2^192 - 1",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^192 vs 2^192",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      "1000000000000000000000000000000000000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^256 - 1 vs 2^256 - 2",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
		wantCmp: 1,
	}, {
		name:    "2^256 - 1 vs 2^256 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}}

	for _, test := range tests {
		// Ensure comparing the numbers produces the expected cmp result.
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		gotCmp := n1.Cmp(n2)
		if gotCmp != test.wantCmp {
			t.Errorf("%q: incorrect cmp result -- got: %v, want: %v", test.name,
				gotCmp, test.wantCmp)
			continue
		}

		// Ensure comparing the numbers produces the expected == result.
		isEq := n1.Eq(n2)
		wantEq := test.wantCmp == 0
		if isEq != wantEq {
			t.Errorf("%q: incorrect == result -- got: %v, want: %v", test.name,
				isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.Lt(n2)
		wantLt := test.wantCmp < 0
		if isLt != wantLt {
			t.Errorf("%q: incorrect < result -- got: %v, want: %v", test.name,
				isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEq(n2)
		wantLtEq := test.wantCmp <= 0
		if isLtEq != wantLtEq {
			t.Errorf("%q: incorrect <= result -- got: %v, want: %v", test.name,
				isLtEq, wantLtEq)
			continue
		}

		// Ensure comparing the numbers produces the expected > result.
		isGt := n1.Gt(n2)
		wantGt := test.wantCmp > 0
		if isGt != wantGt {
			t.Errorf("%q: incorrect > result -- got: %v, want: %v", test.name,
				isGt, wantGt)
			continue
		}

		// Ensure comparing the numbers produces the expected >= result.
		isGtEq := n1.GtEq(n2)
		wantGtEq := test.wantCmp >= 0
		if isGtEq != wantGtEq {
			t.Errorf("%q: incorrect >= result -- got: %v, want: %v", test.name,
				isGtEq, wantGtEq)
			continue
		}
	}
}

// TestUint256ComparisonRandom ensures that comparing two uint256s created from
// random values via the various comparison operators works as expected.
func TestUint256ComparisonRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Ensure the uint256s are equal to themselves.
		if !n1.Eq(n1) {
			t.Fatalf("failed equality check -- n1: %x", n1)
		}
		if !n2.Eq(n2) {
			t.Fatalf("failed equality check -- n2: %x", n2)
		}

		// Ensure the uint256 comparison result matches the one using big ints.
		bigCmpResult := bigN1.Cmp(bigN2)
		cmpResult := n1.Cmp(n2)
		if cmpResult != bigCmpResult {
			t.Errorf("incorrect cmp result n1: %x, n2: %x -- got %v, want %v",
				n1, n2, cmpResult, bigCmpResult)
		}

		// Ensure comparing the numbers produces the expected == result.
		isEq := n1.Eq(n2)
		wantEq := bigCmpResult == 0
		if isEq != wantEq {
			t.Errorf("incorrect == result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.Lt(n2)
		wantLt := bigCmpResult < 0
		if isLt != wantLt {
			t.Errorf("incorrect < result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEq(n2)
		wantLtEq := bigCmpResult <= 0
		if isLtEq != wantLtEq {
			t.Errorf("incorrect <= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLtEq, wantLtEq)
			continue
		}

		// Ensure comparing the numbers produces the expected > result.
		isGt := n1.Gt(n2)
		wantGt := bigCmpResult > 0
		if isGt != wantGt {
			t.Errorf("incorrect > result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isGt, wantGt)
			continue
		}

		// Ensure comparing the numbers produces the expected >= result.
		isGtEq := n1.GtEq(n2)
		wantGtEq := bigCmpResult >= 0
		if isGtEq != wantGtEq {
			t.Errorf("incorrect >= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isGtEq, wantGtEq)
			continue
		}
	}
}

// TestUint256ComparisonUint64 ensures that comparing a uint256 and a uint64 via
// the various comparison operators works as expected for edge cases.
func TestUint256ComparisonUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string // test description
		n1      string // hex encoded value
		n2      uint64 // uint64 to compare with
		wantCmp int    // expected comparison result
	}{{
		name:    "0 vs 0",
		n1:      "0",
		n2:      0,
		wantCmp: 0,
	}, {
		name:    "0 vs 1",
		n1:      "0",
		n2:      1,
		wantCmp: -1,
	}, {
		name:    "1 vs 0",
		n1:      "1",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^32 - 1 vs 2^32 - 1",
		n1:      "ffffffff",
		n2:      0xffffffff,
		wantCmp: 0,
	}, {
		name:    "2^32 - 1 vs 2^32",
		n1:      "ffffffff",
		n2:      0x100000000,
		wantCmp: -1,
	}, {
		name:    "2^32 vs 2^32 - 1",
		n1:      "100000000",
		n2:      0xffffffff,
		wantCmp: 1,
	}, {
		name:    "2^32 vs 2^32",
		n1:      "100000000",
		n2:      0x100000000,
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64 - 2",
		n1:      "ffffffffffffffff",
		n2:      0xfffffffffffffffe,
		wantCmp: 1,
	}, {
		name:    "2^64 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 0,
	}, {
		name:    "2^64 vs 2^64 - 1",
		n1:      "10000000000000000",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^128 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^128 vs 0",
		n1:      "100000000000000000000000000000000",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^192 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^192 vs 0",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^256 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}}

	for _, test := range tests {
		// Ensure comparing the numbers produces the expected cmp result.
		n1 := hexToUint256(test.n1)
		gotCmp := n1.CmpUint64(test.n2)
		if gotCmp != test.wantCmp {
			t.Errorf("%q: incorrect cmp result -- got: %v, want: %v", test.name,
				gotCmp, test.wantCmp)
			continue
		}

		// Ensure comparing the numbers produces the expected == result.
		isEq := n1.EqUint64(test.n2)
		wantEq := test.wantCmp == 0
		if isEq != wantEq {
			t.Errorf("%q: incorrect == result -- got: %v, want: %v", test.name,
				isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.LtUint64(test.n2)
		wantLt := test.wantCmp < 0
		if isLt != wantLt {
			t.Errorf("%q: incorrect < result -- got: %v, want: %v", test.name,
				isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEqUint64(test.n2)
		wantLtEq := test.wantCmp <= 0
		if isLtEq != wantLtEq {
			t.Errorf("%q: incorrect <= result -- got: %v, want: %v", test.name,
				isLt, wantLtEq)
			continue
		}

		// Ensure comparing the numbers produces the expected > result.
		isGt := n1.GtUint64(test.n2)
		wantGt := test.wantCmp > 0
		if isGt != wantGt {
			t.Errorf("%q: incorrect > result -- got: %v, want: %v", test.name,
				isGt, wantGt)
			continue
		}

		// Ensure comparing the numbers produces the expected >= result.
		isGtEq := n1.GtEqUint64(test.n2)
		wantGtEq := test.wantCmp >= 0
		if isGtEq != wantGtEq {
			t.Errorf("%q: incorrect >= result -- got: %v, want: %v", test.name,
				isGtEq, wantGtEq)
			continue
		}
	}
}

// TestUint256ComparisonUint64Random ensures that comparing a uint256 vs uint64
// created from random values via the various comparison operators works as
// expected.
func TestUint256ComparisonUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256/uint64 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Ensure a the uint256 truncated to 64 bits equals that truncated
		// 64-bit result.
		truncatedN1Uint64 := n1.Uint64()
		truncatedN1 := new(Uint256).SetUint64(truncatedN1Uint64)
		if !truncatedN1.EqUint64(truncatedN1Uint64) {
			t.Fatalf("failed equality check -- n: %x", truncatedN1)
		}

		// Ensure the uint256 comparison result matches the one using big ints.
		bigCmpResult := bigN1.Cmp(bigN2)
		cmpResult := n1.CmpUint64(n2)
		if cmpResult != bigCmpResult {
			t.Errorf("incorrect cmp result n1: %x, n2: %x -- got %v, want %v",
				n1, n2, cmpResult, bigCmpResult)
		}

		// Ensure comparing the numbers produces the expected == result.
		isEq := n1.EqUint64(n2)
		wantEq := bigCmpResult == 0
		if isEq != wantEq {
			t.Errorf("incorrect == result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.LtUint64(n2)
		wantLt := bigCmpResult < 0
		if isLt != wantLt {
			t.Errorf("incorrect < result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEqUint64(n2)
		wantLtEq := bigCmpResult <= 0
		if isLtEq != wantLtEq {
			t.Errorf("incorrect <= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLtEq, wantLtEq)
			continue
		}

		// Ensure comparing the numbers produces the expected > result.
		isGt := n1.GtUint64(n2)
		wantGt := bigCmpResult > 0
		if isGt != wantGt {
			t.Errorf("incorrect > result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isGt, wantGt)
			continue
		}

		// Ensure comparing the numbers produces the expected >= result.
		isGtEq := n1.GtEqUint64(n2)
		wantGtEq := bigCmpResult >= 0
		if isGtEq != wantGtEq {
			t.Errorf("incorrect >= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isGtEq, wantGtEq)
			continue
		}
	}
}

// TestUint256Add ensures that adding two uint256s works as expected for edge
// cases.
func TestUint256Add(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded test value
		n2   string // second hex encoded test value
		want string // expected hex encoded result
	}{{
		name: "zero + one",
		n1:   "0",
		n2:   "1",
		want: "1",
	}, {
		name: "one + zero",
		n1:   "1",
		n2:   "0",
		want: "1",
	}, {
		name: "max uint256 + 1 (carry in all words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "1",
		want: "0",
	}, {
		name: "max uint256 + 2 (carry in all words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "2",
		want: "1",
	}, {
		name: "(2^64 - 15) + 16 (carry in word zero)",
		n1:   "fffffffffffffff0",
		n2:   "10",
		want: "10000000000000000",
	}, {
		name: "carry in word one",
		n1:   "0000ffff000000000000000000000000",
		n2:   "ffff0001000000000000000000000000",
		want: "100000000000000000000000000000000",
	}, {
		name: "carry in word two",
		n1:   "0000ffff0000000000000000000000000000000000000000",
		n2:   "ffff00010000000000000000000000000000000000000000",
		want: "1000000000000000000000000000000000000000000000000",
	}, {
		name: "carry in word three",
		n1:   "0000ffff00000000000000000000000000000000000000000000000000000000",
		n2:   "ffff000100000000000000000000000000000000000000000000000000000000",
		want: "0",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}}

	for _, test := range tests {
		// Parse test hex.
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		want := hexToUint256(test.want)

		// Ensure adding the two values produces the expected result.
		got := new(Uint256).Add2(n1, n2)
		if !got.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				got, want)
			continue
		}

		// Ensure single argument adding also produces the expected result.
		n1.Add(n2)
		if !n1.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n1, want)
			continue
		}
	}
}

// TestUint256AddRandom ensures that adding two uint256s created from random
// values together works as expected by also performing the same operation with
// big ints and comparing the results.
func TestUint256AddRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Calculate the sum of the values using big ints.
		bigIntResult := new(big.Int).Add(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the sum of the values using uint256s.
		uint256Result := new(Uint256).Add2(n1, n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched add n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256AddUint64 ensures that adding a uint64 to a uint256 works as
// expected for edge cases.
func TestUint256AddUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded test value
		n2   uint64 // uint64 test value
		want string // expected hex encoded result
	}{{
		name: "zero + one",
		n1:   "0",
		n2:   1,
		want: "1",
	}, {
		name: "one + zero",
		n1:   "1",
		n2:   0,
		want: "1",
	}, {
		name: "max uint256 + 1 (carry in all words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   1,
		want: "0",
	}, {
		name: "max uint256 + 2 (carry in all words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   2,
		want: "1",
	}, {
		name: "(2^64 - 15) + 16 (carry in word zero)",
		n1:   "fffffffffffffff0",
		n2:   0x10,
		want: "10000000000000000",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   0x5a5a5a5a5a5a5a5a,
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5ffffffffffffffff",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   0xa5a5a5a5a5a5a5a5,
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5affffffffffffffff",
	}}

	for _, test := range tests {
		// Parse test hex.
		n1 := hexToUint256(test.n1)
		want := hexToUint256(test.want)

		// Ensure the result is the expected value.
		n1.AddUint64(test.n2)
		if !n1.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n1, want)
			continue
		}
	}
}

// TestUint256AddUint64Random ensures that adding a uint64 to a uint256
// together, both created from random values, works as expected by also
// performing the same operation with big ints and comparing the results.
func TestUint256AddUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Calculate the sum of the values using big ints.
		bigIntResult := new(big.Int).Add(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the sum of the values using uint256s.
		uint256Result := new(Uint256).Set(n1).AddUint64(n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched add n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256Sub ensures that subtracting two uint256s works as expected for
// edge cases.
func TestUint256Sub(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded test value
		n2   string // second hex encoded test value
		want string // expected hex encoded result
	}{{
		name: "zero - one (borrow in all words)",
		n1:   "0",
		n2:   "1",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "one - zero",
		n1:   "1",
		n2:   "0",
		want: "1",
	}, {
		name: "max uint256 - 1",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "1",
		want: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^64 + 15) - 16 (borrow in word zero)",
		n1:   "1000000000000000f",
		n2:   "10",
		want: "ffffffffffffffff",
	}, {
		name: "borrow in word one",
		n1:   "100000000000000000000000000000000",
		n2:   "080000000000000000000000000000000",
		want: "80000000000000000000000000000000",
	}, {
		name: "borrow in word two",
		n1:   "1000000000000000000000000000000000000000000000000",
		n2:   "0800000000000000000000000000000000000000000000000",
		want: "800000000000000000000000000000000000000000000000",
	}, {
		name: "borrow in word three",
		n1:   "6000000000000000000000000000000000000000000000000000000000000000",
		n2:   "8000000000000000000000000000000000000000000000000000000000000000",
		want: "e000000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b5",
	}}

	for _, test := range tests {
		// Parse test hex.
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		want := hexToUint256(test.want)

		// Ensure subtracting the two values produces the expected result.
		got := new(Uint256).Sub2(n1, n2)
		if !got.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				got, want)
			continue
		}

		// Ensure single argument subtracting also produces the expected result.
		n1.Sub(n2)
		if !n1.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n1, want)
			continue
		}
	}
}

// TestUint256SubRandom ensures that subtracting two uint256s created from
// random values works as expected by also performing the same operation with
// big ints and comparing the results.
func TestUint256SubRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Calculate the difference of the values using big ints.
		bigIntResult := new(big.Int).Sub(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the difference of the values using uint256s.
		uint256Result := new(Uint256).Sub2(n1, n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched sub n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256SubUint64 ensures that adding a uint64 to a uint256 works as
// expected for edge cases.
func TestUint256SubUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded test value
		n2   uint64 // uint64 test value
		want string // expected hex encoded result
	}{{
		name: "zero - one (borrow in all words)",
		n1:   "0",
		n2:   1,
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "one - zero",
		n1:   "1",
		n2:   0,
		want: "1",
	}, {
		name: "max uint256 - 1",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   1,
		want: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^64 + 15) - 16 (borrow in word zero)",
		n1:   "1000000000000000f",
		n2:   0x10,
		want: "ffffffffffffffff",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   0x5a5a5a5a5a5a5a5a,
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a54b4b4b4b4b4b4b4b",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   0xa5a5a5a5a5a5a5a5,
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a59b4b4b4b4b4b4b4b5",
	}}

	for _, test := range tests {
		// Parse test hex.
		n1 := hexToUint256(test.n1)
		want := hexToUint256(test.want)

		// Ensure the result is the expected value.
		n1.SubUint64(test.n2)
		if !n1.Eq(want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n1, want)
			continue
		}
	}
}

// TestUint256SubUint64Random ensures that subtracting a uint64 from a uint256
// together, both created from random values, works as expected by also
// performing the same operation with big ints and comparing the results.
func TestUint256SubUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Calculate the difference of the values using big ints.
		bigIntResult := new(big.Int).Sub(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the difference of the values using uint256s.
		uint256Result := new(Uint256).Set(n1).SubUint64(n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched sub n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256Mul ensures that multiplying two uint256s together works as
// expected for edge cases.
func TestUint256Mul(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded value
		n2   string // second hex encoded value to multiply with
		want string // expected hex encoded value
	}{{
		name: "zero * zero",
		n1:   "0",
		n2:   "0",
		want: "0",
	}, {
		name: "zero * one",
		n1:   "0",
		n2:   "1",
		want: "0",
	}, {
		name: "one * zero",
		n1:   "1",
		n2:   "0",
		want: "0",
	}, {
		name: "one * one",
		n1:   "1",
		n2:   "1",
		want: "1",
	}, {
		name: "(2^64 - 1) * 2 (carry to word 1)",
		n1:   "ffffffffffffffff",
		n2:   "2",
		want: "1fffffffffffffffe",
	}, {
		name: "(2^128 - 1) * 2  (carry to word 2)",
		n1:   "ffffffffffffffffffffffffffffffff",
		n2:   "2",
		want: "1fffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^192 - 1) * 2  (carry to word 3)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "2",
		want: "1fffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^256 - 1) * 2  (carry to word 4)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "2",
		want: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^256 - 1) * (2^256 - 1) (carry through all 8 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "1",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "4d10d4985c1fe3a76b2ef2b67a3e01c5894d10d4985c1fe3a76b2ef2b67a3e02",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "4d10d4985c1fe3a76b2ef2b67a3e01c5894d10d4985c1fe3a76b2ef2b67a3e02",
	}}

	for _, test := range tests {
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		want := hexToUint256(test.want)

		// Ensure multiplying two other values produces the expected result.
		got := new(Uint256).Mul2(n1, n2)
		if !got.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				want)
			continue
		}

		// Ensure single argument multiplying also produces the expected result.
		n1.Mul(n2)
		if !n1.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n1,
				want)
			continue
		}
	}
}

// TestUint256MulRandom ensures that multiplying two uint256s created from
// random values together works as expected by also performing the same
// operation with big ints and comparing the results.
func TestUint256MulRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Calculate the product of the values using big ints.
		bigIntResult := new(big.Int).Mul(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the product of the values using uint256s.
		uint256Result := new(Uint256).Mul2(n1, n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched mul n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256MulUint64 ensures that multiplying a uint256 by a uint64 works as
// expected for edge cases.
func TestUint256MulUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded value
		n2   uint64 // uint64 to multiply with
		want string // expected hex encoded value
	}{{
		name: "zero * zero",
		n1:   "0",
		n2:   0,
		want: "0",
	}, {
		name: "zero * one",
		n1:   "0",
		n2:   1,
		want: "0",
	}, {
		name: "one * zero",
		n1:   "1",
		n2:   0,
		want: "0",
	}, {
		name: "one * one",
		n1:   "1",
		n2:   1,
		want: "1",
	}, {
		name: "(2^64 - 1) * 2 (carry to word 1)",
		n1:   "ffffffffffffffff",
		n2:   2,
		want: "1fffffffffffffffe",
	}, {
		name: "(2^128 - 1) * 2  (carry to word 2)",
		n1:   "ffffffffffffffffffffffffffffffff",
		n2:   2,
		want: "1fffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^192 - 1) * 2  (carry to word 3)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   2,
		want: "1fffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^256 - 1) * 2  (carry to word 4)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   2,
		want: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
	}, {
		name: "(2^256 - 1) * (2^64 - 1) (max uint64)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   0xffffffffffffffff,
		want: "ffffffffffffffffffffffffffffffffffffffffffffffff0000000000000001",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   0x5a5a5a5a5a5a5a5a,
		want: "e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1a76b2ef2b67a3e02",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   0xa5a5a5a5a5a5a5a5,
		want: "e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e1a76b2ef2b67a3e02",
	}}

	for _, test := range tests {
		n1 := hexToUint256(test.n1)
		want := hexToUint256(test.want)

		// Ensure single multiplying produces the expected result.
		n1.MulUint64(test.n2)
		if !n1.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n1,
				want)
			continue
		}
	}
}

// TestUint256MulUint64Random ensures that multiplying a uint256 by a uint64,
// both created from random values, works as expected by also performing the
// same operation with big ints and comparing the results.
func TestUint256MulUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Calculate the product of the values using big ints.
		bigIntResult := new(big.Int).Mul(bigN1, bigN2)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the product of the values using uint256s.
		uint256Result := new(Uint256).Set(n1).MulUint64(n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched mul n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256Square ensures that squaring uint256s works as expected for edge
// cases.
func TestUint256Square(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded test value
		want string // expected hex encoded value
	}{{
		name: "zero",
		n:    "0",
		want: "0",
	}, {
		name: "one",
		n:    "1",
		want: "1",
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: "fffffffffffffffe0000000000000001",
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: "100000000000000000000000000000000",
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: "fffffffffffffffffffffffffffffffe00000000000000000000000000000001",
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: "0",
	}, {
		name: "2^192 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "fffffffffffffffe000000000000000000000000000000000000000000000001",
	}, {
		name: "2^192",
		n:    "1000000000000000000000000000000000000000000000000",
		want: "0",
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "1",
	}, {
		name: "alternating bits",
		n:    "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "0d4985c1fe3a76b2ef2b67a3e01c5894d10d4985c1fe3a76b2ef2b67a3e01c59",
	}, {
		name: "alternating bits 2",
		n:    "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "5894d10d4985c1fe3a76b2ef2b67a3e01c5894d10d4985c1fe3a76b2ef2b67a4",
	}}

	for _, test := range tests {
		n := hexToUint256(test.n)
		want := hexToUint256(test.want)

		// Ensure squaring a value produces the expected result.
		got := new(Uint256).SquareVal(n)
		if !got.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				want)
			continue
		}

		// Ensure self squaring also produces the expected result.
		n.Square()
		if !n.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n,
				want)
			continue
		}
	}
}

// TestUint256SquareRandom ensures that squaring uint256s created from random
// values works as expected by also performing the same operation with big ints
// and comparing the results.
func TestUint256SquareRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate big integer and uint256 pair.
		bigN, n := randBigIntAndUint256(t, rng)

		// Calculate the square of the value using big ints.
		bigIntResult := new(big.Int).Mul(bigN, bigN)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the square of the value using uint256s.
		uint256Result := new(Uint256).SquareVal(n)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched square n: %x -- got %x, want %x", n,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256NumDigitsZero ensures that determining the number of digits for
// the value of zero returns zero digits.
func TestUint256NumDigitsZero(t *testing.T) {
	t.Parallel()

	var zero Uint256
	if got := zero.numDigits(); got != 0 {
		t.Fatalf("unexpected number of digits -- got %d, want %d", got, 0)
	}
}

// TestUint256Div ensures that dividing uint256s works as expected for edge
// cases.
func TestUint256Div(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // first hex encoded value
		n2   string // second hex encoded value
		want string // expected hex encoded value
	}{{
		name: "0 / 1",
		n1:   "0",
		n2:   "1",
		want: "0",
	}, {
		name: "1 / 1",
		n1:   "1",
		n2:   "1",
		want: "1",
	}, {
		name: "(2^64 - 1) / (2^32 - 1) (divisor max uint32 < dividend max uint64)",
		n1:   "ffffffffffffffff",
		n2:   "ffffffff",
		want: "100000001",
	}, {
		name: "(2^64 - 1) / (2^64 - 2) (dividend and divisor both uint64)",
		n1:   "ffffffffffffffff",
		n2:   "fffffffffffffffe",
		want: "1",
	}, {
		name: "(2^64 - 1) / (2^64) (dividend max uint64 < divisor)",
		n1:   "ffffffffffffffff",
		n2:   "10000000000000000",
		want: "0",
	}, {
		name: "(2^256 - 1) / (2^64 - 1) (divisor max uint64 < dividend)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "ffffffffffffffff",
		want: "0000000000000001000000000000000100000000000000010000000000000001",
	}, {
		name: "Divisor scaling factor 0 (aka no normalization needed)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "ffffffffffffffff0000000000000000",
		want: "0100000000000000010000000000000001",
	}, {
		name: "Divisor scaling factor 2^1 (with 2 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "7a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "0217a17a17a17a17a17a17a17a17a17a19",
	}, {
		name: "Divisor scaling factor 2^2 (with 2 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "3a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "046318c6318c6318c6318c6318c6318c69",
	}, {
		name: "Divisor scaling factor 2^3 (with 2 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "1a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "09b6db6db6db6db6db6db6db6db6db6dd8",
	}, {
		name: "Divisor scaling factor 2^4 (with 2 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "0a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "18ba2e8ba2e8ba2e8ba2e8ba2e8ba2e991",
	}, {
		name: "Divisor scaling factor 2^5 (with 3 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "075a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "22d0e5604189374bc6",
	}, {
		name: "Divisor scaling factor 2^6 (with 3 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "035a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "4c59d31674c59d3167",
	}, {
		name: "Divisor scaling factor 2^7 (with 3 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "015a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "bd37a6f4de9bd37a6f",
	}, {
		name: "Divisor scaling factor 2^8 (with 3 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "005a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "2d55555555555555555",
	}, {
		name: "Divisor scaling factor 2^60 (with 4 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "000000000000000fa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "105c64171905c641",
	}, {
		name: "Divisor scaling factor 2^61 (with 4 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "0000000000000007a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "217a17a17a17a17a",
	}, {
		name: "Divisor scaling factor 2^62 (with 4 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "0000000000000003a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "46318c6318c6318c",
	}, {
		name: "Divisor scaling factor 2^63 (max possible, with 4 words)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "0000000000000001a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "9b6db6db6db6db6d",
	}, {
		name: "Divisor scaling factor 2^12",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "000fffffffffffff0000000000000000",
		want: "100000000000010000000000001000000000",
	}, {
		name: "(2^256 - 1) / (2^256 - 1) (divisor == dividend with max uint256)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "1",
	}, {
		name: "(2^256 - 2) / (2^256 - 1) (divisor > dividend with max uint256)",
		n1:   "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
		n2:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "0",
	}, {
		name: "one overestimate in full div",
		n1:   "00000000000000020000000000000000",
		n2:   "00000000000000010000000000000001",
		want: "1",
	}, {
		name: "two overestimates in full div",
		n1:   "000000000000000180000000000000000000000000000000",
		n2:   "00000000000000020000000000000003",
		want: "bffffffffffffffe",
	}, {
		name: "three overestimates in full div",
		n1:   "000000000000000400000000000000010000000000000000",
		n2:   "00000000000000020000000000000003",
		want: "1fffffffffffffffd",
	}, {
		name: "four overestimates in full div",
		n1:   "0000000000000001c00000000000000000000000000000000000000000000000",
		n2:   "00000000000000020000000000000003",
		want: "dffffffffffffffeb000000000000001",
	}, {
		name: "five overestimates in full div (max possible)",
		n1:   "4000000000000004000000000000000100000000000000010000000000000000",
		n2:   "00000000000000020000000000000003",
		want: "2000000000000001cffffffffffffffdc800000000000003",
	}, {
		name: "place 2^128 estimate overflow min val (divisor digit == 2^63)",
		n1:   "000000000000000100000000000000000000000000000000",
		n2:   "000000000000000000000000000000010000000000000001",
		want: "ffffffffffffffff",
	}, {
		name: "place 2^128 estimate overflow max instance (divisor digit == 2^64-1)",
		n1:   "fffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffff",
		n2:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffff",
	}, {
		name: "place 2^128 estimate overflow plus correction",
		n1:   "000000000000001000000000000000000000000000000000",
		n2:   "000000000000000000000000000000100000000000000011",
		want: "fffffffffffffffe",
	}, {
		name: "place 2^128 estimate overflow min val (divisor digit == 2^63)",
		n1:   "0000000000000001000000000000000000000000000000000000000000000000",
		n2:   "0000000000000000000000000000000100000000000000000000000000000001",
		want: "ffffffffffffffff",
	}, {
		name: "place 2^192 estimate overflow max instance (divisor digit == 2^64-1)",
		n1:   "fffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffff",
		n2:   "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffff",
	}, {
		name: "place 2^192 estimate overflow plus correction",
		n1:   "0000000000000001000000000000000000000000000000000000000000000000",
		n2:   "0000000000000000000000000000000100000000000000010000000000000010",
		want: "fffffffffffffffe",
	}, {
		name: "1 by 1 word division",
		n1:   "9ec1968abe4be60c",
		n2:   "7882e0ef10ad6333",
		want: "1",
	}, {
		name: "2 by 1 word division",
		n1:   "1ee7877f5f0d918d87ff2d8df5475a71",
		n2:   "3c7c5921ce59535e",
		want: "82ccc7899eb1f7d3",
	}, {
		name: "3 by 1 word division",
		n1:   "2cafa3e891df1023a149b587a81fe1c6e29ef876d2f1076f",
		n2:   "6f69c5864e2b6302",
		want: "66ad79286546f29cc022cd5621075865",
	}, {
		name: "4 by 1 word division",
		n1:   "859dcf75d21abb168921e000faaa91e0cc7f351857c054997f57935512a9acd3",
		n2:   "9fafdc72ff55ad30",
		want: "d63495d2e66c2c6d9948d9be0c90a4cbf282d7f069f0d00b",
	}, {
		name: "2 by 2 word division",
		n1:   "b4bd27f8f94b274d0c720bef2840d2c8",
		n2:   "a51475e9b9fe383f275ee4130be38f05",
		want: "1",
	}, {
		name: "3 by 2 word division",
		n1:   "d75621a1a66e56100a458d6798e45f73dffe19dc15dcf5e3",
		n2:   "fc8bc284d73ba47cc9f035ed496b6493",
		want: "da4816fd39b9beb3",
	}, {
		name: "4 by 2 word division",
		n1:   "07c3dad55fdbcde468fe1012b9a870f45479dec3a856fe19466f7151636bab2e",
		n2:   "298eb48cf26c33ff40ff678fcaf66765",
		want: "2fd57ae59007eb97d1506aff05fa6a0d",
	}, {
		name: "5 by 2 word division",
		n1:   "edce7b22ea206400183f1f3495ff19b401206f942ff0667fe038faae7086b750",
		n2:   "268b13d263e82dc7a2d5fa8e2ee6e85e",
		want: "62b7be8d25b7099268b3cd12c9975f808",
	}, {
		name: "3 by 3 word division",
		n1:   "e266a16277f9d230fd6dbc29ebdd73c1bde3fc3c227bef9c",
		n2:   "8d1a0e0a050a5c3bcdba1ab9483bde24ee2d69c977076af0",
		want: "1",
	}, {
		name: "4 by 3 word division",
		n1:   "e1543f55bf97d87f93cba9e0f33a12b1e3731236ad1558251ae5e2bed34c1517",
		n2:   "814e09a35d405b258b40a28558d2ed6e128ad239561e2b45",
		want: "1be1c4b3fca685eb4",
	}, {
		name: "5 by 3 word division",
		n1:   "e4bdee26d527d18ebaaa10b4c0490ee22bdfa5f714ece496e99cb4247ed032c4",
		n2:   "2d34ea7ab3826dbca03bd4377fed82072a48c5743ec8369d",
		want: "50f565bf6a8060a26",
	}, {
		name: "4 by 4 word division",
		n1:   "eed0d2d3ab6c94a36fa96d100c783928dffffff4f18e24720a3532c3466590cd",
		n2:   "db14897e65d547ace12e740764d0a9d0f237b4b13c033df350d6c7c21c4fa0ea",
		want: "1",
	}, {
		name: "5 by 4 word division",
		n1:   "a879b1126365967b908c16e46f3a6332af5ca667fe92f2ae685fcf158da6f8d9",
		n2:   "2776bc3b312cdc32d506dc02a93d2dcd7de59c615451be57ae19d3c8ca5a9d59",
		want: "4",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "1",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "0",
	}}

	for _, test := range tests {
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		want := hexToUint256(test.want)

		// Ensure dividing two other values produces the expected result.
		got := new(Uint256).Div2(n1, n2)
		if !got.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				want)
			continue
		}

		// Ensure single argument division also produces the expected result.
		n1.Div(n2)
		if !n1.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n1,
				want)
			continue
		}
	}
}

// TestUint256DivRandom ensures that dividing two uint256s created from random
// values works as expected by also performing the same operation with big ints
// and comparing the results.
func TestUint256DivRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Calculate the quotient of the values using big ints.
		bigIntResult := new(big.Int).Div(bigN1, bigN2)

		// Calculate the quotient of the values using uint256s.
		uint256Result := new(Uint256).Div2(n1, n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched div n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256DivUint64 ensures that dividing a uint256 by a uint64 works as
// expected for edge cases.
func TestUint256DivUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n1   string // hex encoded dividend
		n2   uint64 // uint64 divisor
		want string // expected hex encoded value
	}{{
		name: "0 / 1",
		n1:   "0",
		n2:   1,
		want: "0",
	}, {
		name: "1 / 1",
		n1:   "1",
		n2:   1,
		want: "1",
	}, {
		name: "(2^64 - 1) / (2^32 - 1) (divisor max uint32 < dividend max uint64)",
		n1:   "ffffffffffffffff",
		n2:   0xffffffff,
		want: "100000001",
	}, {
		name: "(2^64 - 1) / (2^64 - 2) (dividend and divisor both uint64)",
		n1:   "ffffffffffffffff",
		n2:   0xfffffffffffffffe,
		want: "1",
	}, {
		name: "(2^256 - 1) / (2^64 - 1) (divisor max uint64 < dividend)",
		n1:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:   0xffffffffffffffff,
		want: "0000000000000001000000000000000100000000000000010000000000000001",
	}, {
		name: "1 by 1 word division",
		n1:   "9ec1968abe4be60c",
		n2:   0x7882e0ef10ad6333,
		want: "1",
	}, {
		name: "2 by 1 word division",
		n1:   "1ee7877f5f0d918d87ff2d8df5475a71",
		n2:   0x3c7c5921ce59535e,
		want: "82ccc7899eb1f7d3",
	}, {
		name: "3 by 1 word division",
		n1:   "2cafa3e891df1023a149b587a81fe1c6e29ef876d2f1076f",
		n2:   0x6f69c5864e2b6302,
		want: "66ad79286546f29cc022cd5621075865",
	}, {
		name: "4 by 1 word division",
		n1:   "859dcf75d21abb168921e000faaa91e0cc7f351857c054997f57935512a9acd3",
		n2:   0x9fafdc72ff55ad30,
		want: "d63495d2e66c2c6d9948d9be0c90a4cbf282d7f069f0d00b",
	}, {
		name: "alternating bits",
		n1:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		n2:   0x5a5a5a5a5a5a5a5a,
		want: "1d5555555555555572aaaaaaaaaaaaaac8000000000000001",
	}, {
		name: "alternating bits 2",
		n1:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		n2:   0xa5a5a5a5a5a5a5a5,
		want: "8ba2e8ba2e8ba2e945d1745d1745d174e8ba2e8ba2e8ba2f",
	}}

	for _, test := range tests {
		n1 := hexToUint256(test.n1)
		want := hexToUint256(test.want)

		// Ensure single argument division also produces the expected result.
		n1.DivUint64(test.n2)
		if !n1.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n1,
				want)
			continue
		}
	}
}

// TestUint256DivUint64Random ensures that dividing a uint256 by a uint64, both
// created from random values, works as expected by also performing the same
// operation with big ints and comparing the results.
func TestUint256DivUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Calculate the quotient of the values using big ints.
		bigIntResult := new(big.Int).Div(bigN1, bigN2)

		// Calculate the quotient of the values using uint256s.
		uint256Result := new(Uint256).Set(n1).DivUint64(n2)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched div n1: %x, n2: %x -- got %x, want %x", n1, n2,
				bigIntResult, uint256Result)
		}
	}
}

// TestUint256DivByZeroPanic ensures division by zero results in a panic for the
// various division methods.
func TestUint256DivByZeroPanic(t *testing.T) {
	t.Parallel()

	testPanic := func(fn func()) (paniced bool) {
		// Setup a defer to catch the expected panic and update the return
		// variable.
		defer func() {
			if err := recover(); err != nil {
				paniced = true
			}
		}()

		fn()
		return false
	}

	// Ensure attempting to divide by zero via the two parameter variant panics.
	paniced := testPanic(func() {
		var n1, n2 Uint256
		_ = new(Uint256).Div2(&n1, &n2)
	})
	if !paniced {
		t.Fatal("Div2 did not panic on division by zero")
	}

	// Ensure attempting to divide by zero via the single parameter variant
	// panics.
	paniced = testPanic(func() {
		var n1, n2 Uint256
		n1.Div(&n2)
	})
	if !paniced {
		t.Fatal("Div did not panic on division by zero")
	}

	// Ensure attempting to divide by zero via the uint64 parameter variant
	// panics.
	paniced = testPanic(func() {
		var n1 Uint256
		n1.DivUint64(0)
	})
	if !paniced {
		t.Fatal("DivUint64 did not panic on division by zero")
	}
}

// TestUint256Negate ensures that negating uint256s mod 2^256 works as expected
// for edge cases.
func TestUint256Negate(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded test value
		want string // expected hex encoded value
	}{{
		name: "zero",
		n:    "0",
		want: "0",
	}, {
		name: "one",
		n:    "1",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffff0000000000000001",
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000",
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffff00000000000000000000000000000001",
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: "ffffffffffffffffffffffffffffffff00000000000000000000000000000000",
	}, {
		name: "2^192 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffff000000000000000000000000000000000000000000000001",
	}, {
		name: "2^192",
		n:    "1000000000000000000000000000000000000000000000000",
		want: "ffffffffffffffff000000000000000000000000000000000000000000000000",
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "1",
	}, {
		name: "alternating bits",
		n:    "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5b",
	}, {
		name: "alternating bits 2",
		n:    "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a6",
	}}

	for _, test := range tests {
		n := hexToUint256(test.n)
		want := hexToUint256(test.want)

		// Ensure negating a value produces the expected result.
		got := new(Uint256).NegateVal(n)
		if !got.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				want)
			continue
		}
		// Ensure self negation also produces the expected result.
		n.Negate()
		if !n.Eq(want) {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, n,
				want)
			continue
		}
	}
}

// TestUint256NegateRandom ensures that negating uint256s created from random
// values works as expected by also performing the same operation with big ints
// and comparing the results.
func TestUint256NegateRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	two256 := new(big.Int).Lsh(big.NewInt(1), 256)
	for i := 0; i < 100; i++ {
		// Generate big integer and uint256 pair.
		bigN, n := randBigIntAndUint256(t, rng)

		// Calculate the negation of the value using big ints.
		bigIntResult := new(big.Int).Neg(bigN)
		bigIntResult.Mod(bigIntResult, two256)

		// Calculate the negation of the value using uint256s.
		uint256Result := new(Uint256).NegateVal(n)

		// Ensure they match.
		bigIntResultHex := fmt.Sprintf("%064x", bigIntResult.Bytes())
		uint256ResultHex := fmt.Sprintf("%064x", uint256Result.Bytes())
		if bigIntResultHex != uint256ResultHex {
			t.Fatalf("mismatched negate n: %x -- got %x, want %x", n,
				bigIntResult, uint256Result)
		}
	}
}
