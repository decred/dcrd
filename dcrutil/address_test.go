// Copyright (c) 2013, 2014 The btcsuite developers
// Copyright (c) 2015-2019 The Decred developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package dcrutil

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"reflect"
	"testing"

	"github.com/decred/base58"
	"github.com/decred/dcrd/chaincfg/v2/chainec"
	"github.com/decred/dcrd/crypto/ripemd160"
	"github.com/decred/dcrd/dcrec"
	"github.com/decred/dcrd/dcrec/secp256k1/v2"
)

// mockAddrParams implements the AddressParams interface and is used throughout
// the tests to mock multiple networks.
type mockAddrParams struct {
	pubKeyID     [2]byte
	pkhEcdsaID   [2]byte
	pkhEd25519ID [2]byte
	pkhSchnorrID [2]byte
	scriptHashID [2]byte
	privKeyID    [2]byte
}

// AddrIDPubKeyV0 returns the magic prefix bytes associated with the mock params
// for version 0 pay-to-pubkey addresses.
//
// This is part of the AddressParams interface.
func (p *mockAddrParams) AddrIDPubKeyV0() [2]byte {
	return p.pubKeyID
}

// AddrIDPubKeyHashECDSAV0 returns the magic prefix bytes associated with the
// mock params for version 0 pay-to-pubkey-hash addresses where the underlying
// pubkey is secp256k1 and the signature algorithm is ECDSA.
//
// This is part of the AddressParams interface.
func (p *mockAddrParams) AddrIDPubKeyHashECDSAV0() [2]byte {
	return p.pkhEcdsaID
}

// AddrIDPubKeyHashEd25519V0 returns the magic prefix bytes associated with the
// mock params for version 0 pay-to-pubkey-hash addresses where the underlying
// pubkey and signature algorithm are Ed25519.
//
// This is part of the AddressParams interface.
func (p *mockAddrParams) AddrIDPubKeyHashEd25519V0() [2]byte {
	return p.pkhEd25519ID
}

// AddrIDPubKeyHashSchnorrV0 returns the magic prefix bytes associated with the
// mock params for version 0 pay-to-pubkey-hash addresses where the underlying
// pubkey is secp256k1 and the signature algorithm is Schnorr.
//
// This is part of the AddressParams interface.
func (p *mockAddrParams) AddrIDPubKeyHashSchnorrV0() [2]byte {
	return p.pkhSchnorrID
}

// AddrIDScriptHashV0 returns the magic prefix bytes associated with the mock
// params for version 0 pay-to-script-hash addresses.
//
// This is part of the AddressParams interface.
func (p *mockAddrParams) AddrIDScriptHashV0() [2]byte {
	return p.scriptHashID
}

// mockMainNetParams returns mock mainnet address parameters to use throughout
// the tests.  They match the Decred mainnet params as of the time this comment
// was written.
func mockMainNetParams() *mockAddrParams {
	return &mockAddrParams{
		pubKeyID:     [2]byte{0x13, 0x86}, // starts with Dk
		pkhEcdsaID:   [2]byte{0x07, 0x3f}, // starts with Ds
		pkhEd25519ID: [2]byte{0x07, 0x1f}, // starts with De
		pkhSchnorrID: [2]byte{0x07, 0x01}, // starts with DS
		scriptHashID: [2]byte{0x07, 0x1a}, // starts with Dc
		privKeyID:    [2]byte{0x22, 0xde}, // starts with Pm
	}
}

// mockTestNetParams returns mock testnet address parameters to use throughout
// the tests.  They match the Decred mainnet params as of the time this comment
// was written.
func mockTestNetParams() *mockAddrParams {
	return &mockAddrParams{
		pubKeyID:     [2]byte{0x28, 0xf7}, // starts with Tk
		pkhEcdsaID:   [2]byte{0x0f, 0x21}, // starts with Ts
		pkhEd25519ID: [2]byte{0x0f, 0x01}, // starts with Te
		pkhSchnorrID: [2]byte{0x0e, 0xe3}, // starts with TS
		scriptHashID: [2]byte{0x0e, 0xfc}, // starts with Tc
		privKeyID:    [2]byte{0x23, 0x0e}, // starts with Pt
	}
}

// mockRegNetParams returns mock regression test address parameters to use
// throughout the tests.  They match the Decred mainnet params as of the time
// this comment was written.
func mockRegNetParams() *mockAddrParams {
	return &mockAddrParams{
		pubKeyID:     [2]byte{0x25, 0xe5}, // starts with Rk
		pkhEcdsaID:   [2]byte{0x0e, 0x00}, // starts with Rs
		pkhEd25519ID: [2]byte{0x0d, 0xe0}, // starts with Re
		pkhSchnorrID: [2]byte{0x0d, 0xc2}, // starts with RS
		scriptHashID: [2]byte{0x0d, 0xdb}, // starts with Rc
		privKeyID:    [2]byte{0x22, 0xfe}, // starts with Pr
	}
}

// tstAddressPubKey makes an AddressPubKey, setting the unexported fields with
// the parameters.
func tstAddressPubKey(serializedPubKey []byte, pubKeyFormat PubKeyFormat, netID [2]byte) *AddressSecpPubKey {
	pubKey, _ := secp256k1.ParsePubKey(serializedPubKey)
	return &AddressSecpPubKey{
		pubKeyFormat: pubKeyFormat,
		pubKey:       chainec.PublicKey(pubKey),
		pubKeyHashID: netID,
	}
}

func TestAddresses(t *testing.T) {
	mainNetParams := mockMainNetParams()
	testNetParams := mockTestNetParams()
	regNetParams := mockRegNetParams()
	tests := []struct {
		name    string
		addr    string
		saddr   string
		encoded string
		valid   bool
		result  Address
		f       func() (Address, error)
		net     AddressParams
	}{
		// Positive P2PKH tests.
		{
			name:    "mainnet p2pkh",
			addr:    "DsUZxxoHJSty8DCfwfartwTYbuhmVct7tJu",
			encoded: "DsUZxxoHJSty8DCfwfartwTYbuhmVct7tJu",
			valid:   true,
			result: &AddressPubKeyHash{
				hash: [ripemd160.Size]byte{
					0x27, 0x89, 0xd5, 0x8c, 0xfa, 0x09, 0x57, 0xd2, 0x06, 0xf0,
					0x25, 0xc2, 0xaf, 0x05, 0x6f, 0xc8, 0xa7, 0x7c, 0xeb, 0xb0},
				netID: mainNetParams.AddrIDPubKeyHashECDSAV0(),
			},
			f: func() (Address, error) {
				pkHash := []byte{
					0x27, 0x89, 0xd5, 0x8c, 0xfa, 0x09, 0x57, 0xd2, 0x06, 0xf0,
					0x25, 0xc2, 0xaf, 0x05, 0x6f, 0xc8, 0xa7, 0x7c, 0xeb, 0xb0}
				return NewAddressPubKeyHash(pkHash, mainNetParams,
					dcrec.STEcdsaSecp256k1)
			},
			net: mainNetParams,
		},
		{
			name:    "mainnet p2pkh 2",
			addr:    "DsU7xcg53nxaKLLcAUSKyRndjG78Z2VZnX9",
			encoded: "DsU7xcg53nxaKLLcAUSKyRndjG78Z2VZnX9",
			valid:   true,
			result: &AddressPubKeyHash{
				hash: [ripemd160.Size]byte{
					0x22, 0x9e, 0xba, 0xc3, 0x0e, 0xfd, 0x6a, 0x69, 0xee, 0xc9,
					0xc1, 0xa4, 0x8e, 0x04, 0x8b, 0x7c, 0x97, 0x5c, 0x25, 0xf2},
				netID: mainNetParams.AddrIDPubKeyHashECDSAV0(),
			},
			f: func() (Address, error) {
				pkHash := []byte{
					0x22, 0x9e, 0xba, 0xc3, 0x0e, 0xfd, 0x6a, 0x69, 0xee, 0xc9,
					0xc1, 0xa4, 0x8e, 0x04, 0x8b, 0x7c, 0x97, 0x5c, 0x25, 0xf2}
				return NewAddressPubKeyHash(pkHash, mainNetParams,
					dcrec.STEcdsaSecp256k1)
			},
			net: mainNetParams,
		},
		{
			name:    "testnet p2pkh",
			addr:    "Tso2MVTUeVrjHTBFedFhiyM7yVTbieqp91h",
			encoded: "Tso2MVTUeVrjHTBFedFhiyM7yVTbieqp91h",
			valid:   true,
			result: &AddressPubKeyHash{
				hash: [ripemd160.Size]byte{
					0xf1, 0x5d, 0xa1, 0xcb, 0x8d, 0x1b, 0xcb, 0x16, 0x2c, 0x6a,
					0xb4, 0x46, 0xc9, 0x57, 0x57, 0xa6, 0xe7, 0x91, 0xc9, 0x16},
				netID: testNetParams.AddrIDPubKeyHashECDSAV0(),
			},
			f: func() (Address, error) {
				pkHash := []byte{
					0xf1, 0x5d, 0xa1, 0xcb, 0x8d, 0x1b, 0xcb, 0x16, 0x2c, 0x6a,
					0xb4, 0x46, 0xc9, 0x57, 0x57, 0xa6, 0xe7, 0x91, 0xc9, 0x16}
				return NewAddressPubKeyHash(pkHash,
					testNetParams, dcrec.STEcdsaSecp256k1)
			},
			net: testNetParams,
		},
		{
			name:    "regnet p2pkh",
			addr:    "RsWM2w5LPJip56uxcZ1Scq7Tcbg97EfiwPA",
			encoded: "RsWM2w5LPJip56uxcZ1Scq7Tcbg97EfiwPA",
			valid:   true,
			result: &AddressPubKeyHash{
				hash: [ripemd160.Size]byte{
					0xf1, 0x5d, 0xa1, 0xcb, 0x8d, 0x1b, 0xcb, 0x16, 0x2c, 0x6a,
					0xb4, 0x46, 0xc9, 0x57, 0x57, 0xa6, 0xe7, 0x91, 0xc9, 0x16},
				netID: regNetParams.AddrIDPubKeyHashECDSAV0(),
			},
			f: func() (Address, error) {
				pkHash := []byte{
					0xf1, 0x5d, 0xa1, 0xcb, 0x8d, 0x1b, 0xcb, 0x16, 0x2c, 0x6a,
					0xb4, 0x46, 0xc9, 0x57, 0x57, 0xa6, 0xe7, 0x91, 0xc9, 0x16}
				return NewAddressPubKeyHash(pkHash, regNetParams,
					dcrec.STEcdsaSecp256k1)
			},
			net: regNetParams,
		},

		// Negative P2PKH tests.
		{
			name:  "p2pkh wrong hash length",
			addr:  "",
			valid: false,
			f: func() (Address, error) {
				pkHash := []byte{
					0x00, 0x0e, 0xf0, 0x30, 0x10, 0x7f, 0xd2, 0x6e, 0x0b, 0x6b,
					0xf4, 0x05, 0x12, 0xbc, 0xa2, 0xce, 0xb1, 0xdd, 0x80, 0xad,
					0xaa}
				return NewAddressPubKeyHash(pkHash, mainNetParams,
					dcrec.STEcdsaSecp256k1)
			},
		},
		{
			name:  "p2pkh bad checksum",
			addr:  "TsmWaPM77WSyA3aiQ2Q1KnwGDVWvEkhip23",
			valid: false,
			net:   testNetParams,
		},

		// Positive P2SH tests.
		{
			// Taken from transactions:
			// output: 3c9018e8d5615c306d72397f8f5eef44308c98fb576a88e030c25456b4f3a7ac
			// input:  837dea37ddc8b1e3ce646f1a656e79bbd8cc7f558ac56a169626d649ebe2a3ba.
			name:    "mainnet p2sh",
			addr:    "DcuQKx8BES9wU7C6Q5VmLBjw436r27hayjS",
			encoded: "DcuQKx8BES9wU7C6Q5VmLBjw436r27hayjS",
			valid:   true,
			result: &AddressScriptHash{
				hash: [ripemd160.Size]byte{
					0xf0, 0xb4, 0xe8, 0x51, 0x00, 0xae, 0xe1, 0xa9, 0x96, 0xf2,
					0x29, 0x15, 0xeb, 0x3c, 0x3f, 0x76, 0x4d, 0x53, 0x77, 0x9a},
				netID: mainNetParams.AddrIDScriptHashV0(),
			},
			f: func() (Address, error) {
				txscript := []byte{
					0x51, 0x21, 0x03, 0xaa, 0x43, 0xf0, 0xa6, 0xc1, 0x57, 0x30,
					0xd8, 0x86, 0xcc, 0x1f, 0x03, 0x42, 0x04, 0x6d, 0x20, 0x17,
					0x54, 0x83, 0xd9, 0x0d, 0x7c, 0xcb, 0x65, 0x7f, 0x90, 0xc4,
					0x89, 0x11, 0x1d, 0x79, 0x4c, 0x51, 0xae}
				return NewAddressScriptHash(txscript, mainNetParams)
			},
			net: mainNetParams,
		},
		{
			// Taken from transactions:
			// output: b0539a45de13b3e0403909b8bd1a555b8cbe45fd4e3f3fda76f3a5f52835c29d
			// input: (not yet redeemed at time test was written)
			name:    "mainnet p2sh 2",
			addr:    "DcqgK4N4Ccucu2Sq4VDAdu4wH4LASLhzLVp",
			encoded: "DcqgK4N4Ccucu2Sq4VDAdu4wH4LASLhzLVp",
			valid:   true,
			result: &AddressScriptHash{
				hash: [ripemd160.Size]byte{
					0xc7, 0xda, 0x50, 0x95, 0x68, 0x34, 0x36, 0xf4, 0x43, 0x5f,
					0xc4, 0xe7, 0x16, 0x3d, 0xca, 0xfd, 0xa1, 0xa2, 0xd0, 0x07},
				netID: mainNetParams.AddrIDScriptHashV0(),
			},
			f: func() (Address, error) {
				hash := []byte{
					0xc7, 0xda, 0x50, 0x95, 0x68, 0x34, 0x36, 0xf4, 0x43, 0x5f,
					0xc4, 0xe7, 0x16, 0x3d, 0xca, 0xfd, 0xa1, 0xa2, 0xd0, 0x07}
				return NewAddressScriptHashFromHash(hash, mainNetParams)
			},
			net: mainNetParams,
		},
		{
			// Taken from bitcoind base58_keys_valid.
			name:    "testnet p2sh",
			addr:    "TccWLgcquqvwrfBocq5mcK5kBiyw8MvyvCi",
			encoded: "TccWLgcquqvwrfBocq5mcK5kBiyw8MvyvCi",
			valid:   true,
			result: &AddressScriptHash{
				hash: [ripemd160.Size]byte{
					0x36, 0xc1, 0xca, 0x10, 0xa8, 0xa6, 0xa4, 0xb5, 0xd4, 0x20,
					0x4a, 0xc9, 0x70, 0x85, 0x39, 0x79, 0x90, 0x3a, 0xa2, 0x84},
				netID: testNetParams.AddrIDScriptHashV0(),
			},
			f: func() (Address, error) {
				hash := []byte{
					0x36, 0xc1, 0xca, 0x10, 0xa8, 0xa6, 0xa4, 0xb5, 0xd4, 0x20,
					0x4a, 0xc9, 0x70, 0x85, 0x39, 0x79, 0x90, 0x3a, 0xa2, 0x84}
				return NewAddressScriptHashFromHash(hash, testNetParams)
			},
			net: testNetParams,
		},
		{
			name:    "regnet p2sh",
			addr:    "RcKq28Eheeo2eJvWakqWWAr5pqCUWykwDHe",
			encoded: "RcKq28Eheeo2eJvWakqWWAr5pqCUWykwDHe",
			valid:   true,
			result: &AddressScriptHash{
				hash: [ripemd160.Size]byte{
					0x36, 0xc1, 0xca, 0x10, 0xa8, 0xa6, 0xa4, 0xb5, 0xd4, 0x20,
					0x4a, 0xc9, 0x70, 0x85, 0x39, 0x79, 0x90, 0x3a, 0xa2, 0x84},
				netID: regNetParams.AddrIDScriptHashV0(),
			},
			f: func() (Address, error) {
				hash := []byte{
					0x36, 0xc1, 0xca, 0x10, 0xa8, 0xa6, 0xa4, 0xb5, 0xd4, 0x20,
					0x4a, 0xc9, 0x70, 0x85, 0x39, 0x79, 0x90, 0x3a, 0xa2, 0x84}
				return NewAddressScriptHashFromHash(hash, regNetParams)
			},
			net: regNetParams,
		},

		// Negative P2SH tests.
		{
			name:  "p2sh wrong hash length",
			addr:  "",
			valid: false,
			f: func() (Address, error) {
				hash := []byte{
					0x00, 0xf8, 0x15, 0xb0, 0x36, 0xd9, 0xbb, 0xbc, 0xe5, 0xe9,
					0xf2, 0xa0, 0x0a, 0xbd, 0x1b, 0xf3, 0xdc, 0x91, 0xe9, 0x55,
					0x10}
				return NewAddressScriptHashFromHash(hash, mainNetParams)
			},
			net: mainNetParams,
		},

		// Positive P2PK tests.
		{
			name:    "mainnet p2pk compressed (0x02)",
			addr:    "DsT4FDqBKYG1Xr8aGrT1rKP3kiv6TZ5K5th",
			encoded: "DsT4FDqBKYG1Xr8aGrT1rKP3kiv6TZ5K5th",
			valid:   true,
			result: tstAddressPubKey(
				[]byte{
					0x02, 0x8f, 0x53, 0x83, 0x8b, 0x76, 0x39, 0x56, 0x3f, 0x27,
					0xc9, 0x48, 0x45, 0x54, 0x9a, 0x41, 0xe5, 0x14, 0x6b, 0xcd,
					0x52, 0xe7, 0xfe, 0xf0, 0xea, 0x6d, 0xa1, 0x43, 0xa0, 0x2b,
					0x0f, 0xe2, 0xed},
				PKFCompressed, mainNetParams.AddrIDPubKeyHashECDSAV0()),
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x02, 0x8f, 0x53, 0x83, 0x8b, 0x76, 0x39, 0x56, 0x3f, 0x27,
					0xc9, 0x48, 0x45, 0x54, 0x9a, 0x41, 0xe5, 0x14, 0x6b, 0xcd,
					0x52, 0xe7, 0xfe, 0xf0, 0xea, 0x6d, 0xa1, 0x43, 0xa0, 0x2b,
					0x0f, 0xe2, 0xed}
				return NewAddressSecpPubKey(serializedPubKey, mainNetParams)
			},
			net: mainNetParams,
		},
		{
			name:    "mainnet p2pk compressed (0x03)",
			addr:    "DsfiE2y23CGwKNxSGjbfPGeEW4xw1tamZdc",
			encoded: "DsfiE2y23CGwKNxSGjbfPGeEW4xw1tamZdc",
			valid:   true,
			result: tstAddressPubKey(
				[]byte{
					0x03, 0xe9, 0x25, 0xaa, 0xfc, 0x1e, 0xdd, 0x44, 0xe7, 0xc7,
					0xf1, 0xea, 0x4f, 0xb7, 0xd2, 0x65, 0xdc, 0x67, 0x2f, 0x20,
					0x4c, 0x3d, 0x0c, 0x81, 0x93, 0x03, 0x89, 0xc1, 0x0b, 0x81,
					0xfb, 0x75, 0xde},
				PKFCompressed, mainNetParams.AddrIDPubKeyHashECDSAV0()),
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x03, 0xe9, 0x25, 0xaa, 0xfc, 0x1e, 0xdd, 0x44, 0xe7, 0xc7,
					0xf1, 0xea, 0x4f, 0xb7, 0xd2, 0x65, 0xdc, 0x67, 0x2f, 0x20,
					0x4c, 0x3d, 0x0c, 0x81, 0x93, 0x03, 0x89, 0xc1, 0x0b, 0x81,
					0xfb, 0x75, 0xde}
				return NewAddressSecpPubKey(serializedPubKey, mainNetParams)
			},
			net: mainNetParams,
		},
		{
			name:    "mainnet p2pk uncompressed (0x04)",
			addr:    "DkM3EyZ546GghVSkvzb6J47PvGDyntqiDtFgipQhNj78Xm2mUYRpf",
			encoded: "DsfFjaADsV8c5oHWx85ZqfxCZy74K8RFuhK",
			valid:   true,
			saddr:   "0264c44653d6567eff5753c5d24a682ddc2b2cadfe1b0c6433b16374dace6778f0",
			result: tstAddressPubKey(
				[]byte{
					0x04, 0x64, 0xc4, 0x46, 0x53, 0xd6, 0x56, 0x7e, 0xff, 0x57,
					0x53, 0xc5, 0xd2, 0x4a, 0x68, 0x2d, 0xdc, 0x2b, 0x2c, 0xad,
					0xfe, 0x1b, 0x0c, 0x64, 0x33, 0xb1, 0x63, 0x74, 0xda, 0xce,
					0x67, 0x78, 0xf0, 0xb8, 0x7c, 0xa4, 0x27, 0x9b, 0x56, 0x5d,
					0x21, 0x30, 0xce, 0x59, 0xf7, 0x5b, 0xfb, 0xb2, 0xb8, 0x8d,
					0xa7, 0x94, 0x14, 0x3d, 0x7c, 0xfd, 0x3e, 0x80, 0x80, 0x8a,
					0x1f, 0xa3, 0x20, 0x39, 0x04},
				PKFUncompressed, mainNetParams.AddrIDPubKeyHashECDSAV0()),
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x04, 0x64, 0xc4, 0x46, 0x53, 0xd6, 0x56, 0x7e, 0xff, 0x57,
					0x53, 0xc5, 0xd2, 0x4a, 0x68, 0x2d, 0xdc, 0x2b, 0x2c, 0xad,
					0xfe, 0x1b, 0x0c, 0x64, 0x33, 0xb1, 0x63, 0x74, 0xda, 0xce,
					0x67, 0x78, 0xf0, 0xb8, 0x7c, 0xa4, 0x27, 0x9b, 0x56, 0x5d,
					0x21, 0x30, 0xce, 0x59, 0xf7, 0x5b, 0xfb, 0xb2, 0xb8, 0x8d,
					0xa7, 0x94, 0x14, 0x3d, 0x7c, 0xfd, 0x3e, 0x80, 0x80, 0x8a,
					0x1f, 0xa3, 0x20, 0x39, 0x04}
				return NewAddressSecpPubKey(serializedPubKey, mainNetParams)
			},
			net: mainNetParams,
		},
		{
			name:    "testnet p2pk compressed (0x02)",
			addr:    "Tso9sQD3ALqRsmEkAm7KvPrkGbeG2Vun7Kv",
			encoded: "Tso9sQD3ALqRsmEkAm7KvPrkGbeG2Vun7Kv",
			valid:   true,
			result: tstAddressPubKey(
				[]byte{
					0x02, 0x6a, 0x40, 0xc4, 0x03, 0xe7, 0x46, 0x70, 0xc4, 0xde,
					0x76, 0x56, 0xa0, 0x9c, 0xaa, 0x23, 0x53, 0xd4, 0xb3, 0x83,
					0xa9, 0xce, 0x66, 0xee, 0xf5, 0x1e, 0x12, 0x20, 0xea, 0xcf,
					0x4b, 0xe0, 0x6e},
				PKFCompressed, testNetParams.AddrIDPubKeyHashECDSAV0()),
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x02, 0x6a, 0x40, 0xc4, 0x03, 0xe7, 0x46, 0x70, 0xc4, 0xde,
					0x76, 0x56, 0xa0, 0x9c, 0xaa, 0x23, 0x53, 0xd4, 0xb3, 0x83,
					0xa9, 0xce, 0x66, 0xee, 0xf5, 0x1e, 0x12, 0x20, 0xea, 0xcf,
					0x4b, 0xe0, 0x6e}
				return NewAddressSecpPubKey(serializedPubKey, testNetParams)
			},
			net: testNetParams,
		},
		{
			name:    "testnet p2pk compressed (0x03)",
			addr:    "TsWZ1EzypJfMwBKAEDYKuyHRGctqGAxMje2",
			encoded: "TsWZ1EzypJfMwBKAEDYKuyHRGctqGAxMje2",
			valid:   true,
			result: tstAddressPubKey(
				[]byte{
					0x03, 0x08, 0x44, 0xee, 0x70, 0xd8, 0x38, 0x4d, 0x52, 0x50,
					0xe9, 0xbb, 0x3a, 0x6a, 0x73, 0xd4, 0xb5, 0xbe, 0xc7, 0x70,
					0xe8, 0xb3, 0x1d, 0x6a, 0x0a, 0xe9, 0xfb, 0x73, 0x90, 0x09,
					0xd9, 0x1a, 0xf5},
				PKFCompressed, testNetParams.AddrIDPubKeyHashECDSAV0()),
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x03, 0x08, 0x44, 0xee, 0x70, 0xd8, 0x38, 0x4d, 0x52, 0x50,
					0xe9, 0xbb, 0x3a, 0x6a, 0x73, 0xd4, 0xb5, 0xbe, 0xc7, 0x70,
					0xe8, 0xb3, 0x1d, 0x6a, 0x0a, 0xe9, 0xfb, 0x73, 0x90, 0x09,
					0xd9, 0x1a, 0xf5}
				return NewAddressSecpPubKey(serializedPubKey, testNetParams)
			},
			net: testNetParams,
		},
		{
			name:    "testnet p2pk uncompressed (0x04)",
			addr:    "TkKmMiY5iDh4U3KkSopYgkU1AzhAcQZiSoVhYhFymZHGMi9LM9Fdt",
			encoded: "Tso9sQD3ALqRsmEkAm7KvPrkGbeG2Vun7Kv",
			valid:   true,
			saddr:   "026a40c403e74670c4de7656a09caa2353d4b383a9ce66eef51e1220eacf4be06e",
			result: tstAddressPubKey(
				[]byte{
					0x04, 0x6a, 0x40, 0xc4, 0x03, 0xe7, 0x46, 0x70, 0xc4, 0xde,
					0x76, 0x56, 0xa0, 0x9c, 0xaa, 0x23, 0x53, 0xd4, 0xb3, 0x83,
					0xa9, 0xce, 0x66, 0xee, 0xf5, 0x1e, 0x12, 0x20, 0xea, 0xcf,
					0x4b, 0xe0, 0x6e, 0xd5, 0x48, 0xc8, 0xc1, 0x6f, 0xb5, 0xeb,
					0x90, 0x07, 0xcb, 0x94, 0x22, 0x0b, 0x3b, 0xb8, 0x94, 0x91,
					0xd5, 0xa1, 0xfd, 0x2d, 0x77, 0x86, 0x7f, 0xca, 0x64, 0x21,
					0x7a, 0xce, 0xcf, 0x22, 0x44},
				PKFUncompressed, testNetParams.AddrIDPubKeyHashECDSAV0()),
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x04, 0x6a, 0x40, 0xc4, 0x03, 0xe7, 0x46, 0x70, 0xc4, 0xde,
					0x76, 0x56, 0xa0, 0x9c, 0xaa, 0x23, 0x53, 0xd4, 0xb3, 0x83,
					0xa9, 0xce, 0x66, 0xee, 0xf5, 0x1e, 0x12, 0x20, 0xea, 0xcf,
					0x4b, 0xe0, 0x6e, 0xd5, 0x48, 0xc8, 0xc1, 0x6f, 0xb5, 0xeb,
					0x90, 0x07, 0xcb, 0x94, 0x22, 0x0b, 0x3b, 0xb8, 0x94, 0x91,
					0xd5, 0xa1, 0xfd, 0x2d, 0x77, 0x86, 0x7f, 0xca, 0x64, 0x21,
					0x7a, 0xce, 0xcf, 0x22, 0x44}
				return NewAddressSecpPubKey(serializedPubKey, testNetParams)
			},
			net: testNetParams,
		},
		{
			name:    "regnet p2pk compressed (0x02)",
			addr:    "RsWUYqptu9hWfQyT8gs4pFd5uhroR5yjiVg",
			encoded: "RsWUYqptu9hWfQyT8gs4pFd5uhroR5yjiVg",
			valid:   true,
			result: tstAddressPubKey(
				[]byte{
					0x02, 0x6a, 0x40, 0xc4, 0x03, 0xe7, 0x46, 0x70, 0xc4, 0xde,
					0x76, 0x56, 0xa0, 0x9c, 0xaa, 0x23, 0x53, 0xd4, 0xb3, 0x83,
					0xa9, 0xce, 0x66, 0xee, 0xf5, 0x1e, 0x12, 0x20, 0xea, 0xcf,
					0x4b, 0xe0, 0x6e},
				PKFCompressed, regNetParams.AddrIDPubKeyHashECDSAV0()),
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x02, 0x6a, 0x40, 0xc4, 0x03, 0xe7, 0x46, 0x70, 0xc4, 0xde,
					0x76, 0x56, 0xa0, 0x9c, 0xaa, 0x23, 0x53, 0xd4, 0xb3, 0x83,
					0xa9, 0xce, 0x66, 0xee, 0xf5, 0x1e, 0x12, 0x20, 0xea, 0xcf,
					0x4b, 0xe0, 0x6e}
				return NewAddressSecpPubKey(serializedPubKey, regNetParams)
			},
			net: regNetParams,
		},
		{
			name:    "regnet p2pk compressed (0x03)",
			addr:    "RsDsggcqZ7XSiq3sC9J4oq3kuj7NefnBshc",
			encoded: "RsDsggcqZ7XSiq3sC9J4oq3kuj7NefnBshc",
			valid:   true,
			result: tstAddressPubKey(
				[]byte{
					0x03, 0x08, 0x44, 0xee, 0x70, 0xd8, 0x38, 0x4d, 0x52, 0x50,
					0xe9, 0xbb, 0x3a, 0x6a, 0x73, 0xd4, 0xb5, 0xbe, 0xc7, 0x70,
					0xe8, 0xb3, 0x1d, 0x6a, 0x0a, 0xe9, 0xfb, 0x73, 0x90, 0x09,
					0xd9, 0x1a, 0xf5},
				PKFCompressed, regNetParams.AddrIDPubKeyHashECDSAV0()),
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x03, 0x08, 0x44, 0xee, 0x70, 0xd8, 0x38, 0x4d, 0x52, 0x50,
					0xe9, 0xbb, 0x3a, 0x6a, 0x73, 0xd4, 0xb5, 0xbe, 0xc7, 0x70,
					0xe8, 0xb3, 0x1d, 0x6a, 0x0a, 0xe9, 0xfb, 0x73, 0x90, 0x09,
					0xd9, 0x1a, 0xf5}
				return NewAddressSecpPubKey(serializedPubKey, regNetParams)
			},
			net: regNetParams,
		},

		// Negative P2PK tests.
		{
			name:  "mainnet p2pk hybrid (0x06)",
			addr:  "",
			valid: false,
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x06, 0x64, 0xc4, 0x46, 0x53, 0xd6, 0x56, 0x7e, 0xff, 0x57,
					0x53, 0xc5, 0xd2, 0x4a, 0x68, 0x2d, 0xdc, 0x2b, 0x2c, 0xad,
					0xfe, 0x1b, 0x0c, 0x64, 0x33, 0xb1, 0x63, 0x74, 0xda, 0xce,
					0x67, 0x78, 0xf0, 0xb8, 0x7c, 0xa4, 0x27, 0x9b, 0x56, 0x5d,
					0x21, 0x30, 0xce, 0x59, 0xf7, 0x5b, 0xfb, 0xb2, 0xb8, 0x8d,
					0xa7, 0x94, 0x14, 0x3d, 0x7c, 0xfd, 0x3e, 0x80, 0x80, 0x8a,
					0x1f, 0xa3, 0x20, 0x39, 0x04}
				return NewAddressSecpPubKey(serializedPubKey, mainNetParams)
			},
			net: mainNetParams,
		},
		{
			name:  "mainnet p2pk hybrid (0x07)",
			addr:  "",
			valid: false,
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x07, 0x34, 0x8d, 0x8a, 0xeb, 0x42, 0x53, 0xca, 0x52, 0x45,
					0x6f, 0xe5, 0xda, 0x94, 0xab, 0x12, 0x63, 0xbf, 0xee, 0x16,
					0xbb, 0x81, 0x92, 0x49, 0x7f, 0x66, 0x63, 0x89, 0xca, 0x96,
					0x4f, 0x84, 0x79, 0x83, 0x75, 0x12, 0x9d, 0x79, 0x58, 0x84,
					0x3b, 0x14, 0x25, 0x8b, 0x90, 0x5d, 0xc9, 0x4f, 0xae, 0xd3,
					0x24, 0xdd, 0x8a, 0x9d, 0x67, 0xff, 0xac, 0x8c, 0xc0, 0xa8,
					0x5b, 0xe8, 0x4b, 0xac, 0x5d}
				return NewAddressSecpPubKey(serializedPubKey, mainNetParams)
			},
			net: mainNetParams,
		},
		{
			name:  "testnet p2pk hybrid (0x06)",
			addr:  "",
			valid: false,
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x06, 0x6a, 0x40, 0xc4, 0x03, 0xe7, 0x46, 0x70, 0xc4, 0xde,
					0x76, 0x56, 0xa0, 0x9c, 0xaa, 0x23, 0x53, 0xd4, 0xb3, 0x83,
					0xa9, 0xce, 0x66, 0xee, 0xf5, 0x1e, 0x12, 0x20, 0xea, 0xcf,
					0x4b, 0xe0, 0x6e, 0xd5, 0x48, 0xc8, 0xc1, 0x6f, 0xb5, 0xeb,
					0x90, 0x07, 0xcb, 0x94, 0x22, 0x0b, 0x3b, 0xb8, 0x94, 0x91,
					0xd5, 0xa1, 0xfd, 0x2d, 0x77, 0x86, 0x7f, 0xca, 0x64, 0x21,
					0x7a, 0xce, 0xcf, 0x22, 0x44}
				return NewAddressSecpPubKey(serializedPubKey, testNetParams)
			},
			net: testNetParams,
		},
		{
			name:  "testnet p2pk hybrid (0x07)",
			addr:  "",
			valid: false,
			f: func() (Address, error) {
				serializedPubKey := []byte{
					0x07, 0xed, 0xd4, 0x07, 0x47, 0xde, 0x90, 0x5a, 0x9b, 0xec,
					0xb1, 0x49, 0x87, 0xa1, 0xa2, 0x6c, 0x1a, 0xdb, 0xd6, 0x17,
					0xc4, 0x5e, 0x15, 0x83, 0xc1, 0x42, 0xa6, 0x35, 0xbf, 0xda,
					0x94, 0x93, 0xdf, 0xa1, 0xc6, 0xd3, 0x67, 0x35, 0x97, 0x49,
					0x65, 0xfe, 0x7b, 0x86, 0x1e, 0x7f, 0x6f, 0xcc, 0x08, 0x7d,
					0xc7, 0xfe, 0x47, 0x38, 0x0f, 0xa8, 0xbd, 0xe0, 0xd9, 0xc3,
					0x22, 0xd5, 0x3c, 0x0e, 0x89}
				return NewAddressSecpPubKey(serializedPubKey, testNetParams)
			},
			net: testNetParams,
		},
	}

	for _, test := range tests {
		// Decode addr and compare error against valid.
		decoded, err := DecodeAddress(test.addr, test.net)
		if (err == nil) != test.valid {
			t.Errorf("%v: decoding test failed: %v", test.name, err)
			return
		}

		if err == nil {
			// Ensure the stringer returns the same address as the
			// original.
			if decodedStringer, ok := decoded.(fmt.Stringer); ok {
				if test.addr != decodedStringer.String() {
					t.Errorf("%v: String on decoded value does not match expected value: %v != %v",
						test.name, test.addr, decodedStringer.String())
					return
				}
			}

			// Encode again and compare against the original.
			encoded := decoded.Address()
			if test.encoded != encoded {
				t.Errorf("%v: decoding and encoding produced different addresses: %v != %v",
					test.name, test.encoded, encoded)
				return
			}

			// Perform type-specific calculations.
			var saddr []byte
			switch d := decoded.(type) {
			case *AddressPubKeyHash:
				decoded := base58.Decode(encoded)
				saddr = decoded[2 : 2+ripemd160.Size]

			case *AddressScriptHash:
				decoded := base58.Decode(encoded)
				saddr = decoded[2 : 2+ripemd160.Size]

			case *AddressSecpPubKey:
				// Ignore the error here since the script
				// address is checked below.
				saddr, err = hex.DecodeString(d.String())
				if err != nil {
					saddr, _ = hex.DecodeString(test.saddr)
				}

			case *AddressEdwardsPubKey:
				// Ignore the error here since the script
				// address is checked below.
				saddr, _ = hex.DecodeString(d.String())

			case *AddressSecSchnorrPubKey:
				// Ignore the error here since the script
				// address is checked below.
				saddr, _ = hex.DecodeString(d.String())
			}

			// Check script address, as well as the Hash160 method for P2PKH and
			// P2SH addresses.
			if !bytes.Equal(saddr, decoded.ScriptAddress()) {
				t.Errorf("%v: script addresses do not match:\n%x != \n%x",
					test.name, saddr, decoded.ScriptAddress())
				return
			}
			switch a := decoded.(type) {
			case *AddressPubKeyHash:
				if h := a.Hash160()[:]; !bytes.Equal(saddr, h) {
					t.Errorf("%v: hashes do not match:\n%x != \n%x",
						test.name, saddr, h)
					return
				}

			case *AddressScriptHash:
				if h := a.Hash160()[:]; !bytes.Equal(saddr, h) {
					t.Errorf("%v: hashes do not match:\n%x != \n%x",
						test.name, saddr, h)
					return
				}
			}
		}

		if !test.valid {
			// If address is invalid, but a creation function exists,
			// verify that it returns a nil addr and non-nil error.
			if test.f != nil {
				_, err := test.f()
				if err == nil {
					t.Errorf("%v: address is invalid but creating new address succeeded",
						test.name)
					return
				}
			}
			continue
		}

		// Valid test, compare address created with f against expected result.
		addr, err := test.f()
		if err != nil {
			t.Errorf("%v: address is valid but creating new address failed with error %v",
				test.name, err)
			return
		}
		if !reflect.DeepEqual(addr.ScriptAddress(), test.result.ScriptAddress()) {
			t.Errorf("%v: created address does not match expected result \n "+
				"	got %x, expected %x",
				test.name, addr.ScriptAddress(), test.result.ScriptAddress())
			return
		}
	}
}
